# Headless.Api.Abstractions


Defines core interfaces and contracts for HTTP request context, user identity, and web client information in ASP.NET Core applications.

## Problem Solved

Provides a standardized abstraction layer for accessing request-scoped context (user, tenant, locale, timezone, client info) without coupling application code to ASP.NET Core's `HttpContext` directly.

## Key Features

- `IRequestContext` - Unified access to request-scoped information (user, tenant, locale, timezone, correlation ID)
- `IWebClientInfoProvider` - Client detection (IP address, user agent, device info)
- `IRequestedApiVersion` - API versioning abstraction
- Framework constants for HTTP headers and common values

## Installation

```bash
dotnet add package Headless.Api.Abstractions
```

## Usage

Inject `IRequestContext` to access request-scoped information:

```csharp
public sealed class OrderService(IRequestContext context)
{
    public async Task<Order> CreateOrderAsync(CreateOrderRequest request, CancellationToken ct)
    {
        var userId = context.User.Id;
        var tenantId = context.Tenant.Id;
        var correlationId = context.CorrelationId;

        // Use context information for auditing, logging, multi-tenancy
        return await _repository.CreateAsync(new Order
        {
            UserId = userId,
            TenantId = tenantId,
            CreatedAt = context.DateStarted
        }, ct).AnyContext();
    }
}
```

## Configuration

No configuration required. This package contains interfaces only.

## Dependencies

- `Headless.BuildingBlocks`

## Side Effects

None. This is an abstractions-only package.

---

# Headless.Api.DataProtection


Extends ASP.NET Core Data Protection to persist encryption keys to blob storage providers.

## Problem Solved

In distributed/containerized environments, ASP.NET Core Data Protection keys must be shared across instances. This package enables key persistence to any `IBlobStorage` implementation (Azure, AWS S3, local filesystem, etc.).

## Key Features

- `PersistKeysToBlobStorage()` extension for `IDataProtectionBuilder`
- Works with any `IBlobStorage` implementation
- Supports factory-based storage resolution for DI scenarios

## Installation

```bash
dotnet add package Headless.Api.DataProtection
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddDataProtection()
    .PersistKeysToBlobStorage();

// Or with explicit storage instance
builder.Services.AddDataProtection()
    .PersistKeysToBlobStorage(storageInstance);

// Or with factory
builder.Services.AddDataProtection()
    .PersistKeysToBlobStorage(sp => sp.GetRequiredService<IBlobStorage>());
```

## Configuration

No specific configuration. Depends on the underlying `IBlobStorage` configuration.

## Dependencies

- `Headless.Blobs.Abstractions`
- `Headless.Checks`
- `Azure.Extensions.AspNetCore.DataProtection.Blobs`
- `Microsoft.AspNetCore.DataProtection`

## Side Effects

- Configures `KeyManagementOptions.XmlRepository` to use blob storage

---

# Headless.Api.FluentValidation


FluentValidation extensions for validating ASP.NET Core `IFormFile` uploads including size, content type, and file signature verification.

## Problem Solved

Provides reusable, type-safe validators for file uploads with proper error messages, eliminating boilerplate validation code for common file upload scenarios and preventing extension spoofing attacks.

## Key Features

- `FileNotEmpty()` - Validates file has content
- `GreaterThanOrEqualTo(bytes)` - Minimum file size validation
- `LessThanOrEqualTo(bytes)` - Maximum file size validation
- `ContentTypes(list)` - MIME type whitelist validation
- `HaveSignatures(inspector, predicate)` - Magic bytes/file signature validation
- Localized error messages (English, Arabic)

## Installation

```bash
dotnet add package Headless.Api.FluentValidation
```

## Quick Start

```csharp
using FluentValidation;
using Headless.FluentValidation;
using FileSignatures;
using FileSignatures.Formats;

public sealed class UploadRequestValidator : AbstractValidator<UploadRequest>
{
    public UploadRequestValidator(IFileFormatInspector inspector)
    {
        RuleFor(x => x.Avatar)
            .FileNotEmpty()
            .LessThanOrEqualTo(5 * 1024 * 1024) // 5MB
            .ContentTypes(["image/jpeg", "image/png"])
            .HaveSignatures(inspector, format => format is Jpeg or Png);
    }
}
```

## Configuration

No configuration required.

## Dependencies

- `Headless.FluentValidation`
- `FileSignatures`
- `Microsoft.AspNetCore.App` (framework reference)

## Side Effects

None.

---

# Headless.Api.Logging.Serilog


Serilog integration for ASP.NET Core APIs with custom enrichers for request context.

## Problem Solved

Enriches Serilog log events with HTTP request context (client IP, user agent, user ID, tenant ID, correlation ID) for better observability and debugging in web applications.

## Key Features

- Custom Serilog enricher middleware
- Client info enrichment (IP, user agent)
- Request context enrichment (user, tenant, correlation ID)
- Integration with `Headless.Logging.Serilog` configuration

## Installation

```bash
dotnet add package Headless.Api.Logging.Serilog
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Register enrichers
builder.Services.AddHeadlessSerilogEnrichers();

var app = builder.Build();

// Use enrichers middleware (place early in pipeline)
app.UseHeadlessSerilogEnrichers();

app.Run();
```

## Configuration

Inherits Serilog configuration from `Headless.Logging.Serilog`. See that package for sink and enricher configuration.

## Dependencies

- `Headless.Api.Abstractions`
- `Headless.Logging.Serilog`
- `Serilog.Enrichers.ClientInfo`
- `Microsoft.AspNetCore.App` (framework reference)

## Side Effects

- Adds middleware to the request pipeline
- Enriches log context per-request

---

# Headless.Api.MinimalApi


Framework integration for ASP.NET Core Minimal APIs with JSON configuration, validation filters, and exception handling.

## Problem Solved

Provides consistent JSON serialization, validation, and exception handling for Minimal API endpoints matching the framework's conventions.

## Key Features

- Pre-configured JSON serialization options
- `MinimalApiValidatorFilter` - FluentValidation integration
- `MinimalApiExceptionFilter` - Standardized exception-to-problem-details mapping
- API versioning integration
- Endpoint discovery extensions

## Installation

```bash
dotnet add package Headless.Api.MinimalApi
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.AddHeadlessApi().ConfigureHeadlessMinimalApi();

var app = builder.Build();

app.MapGet("/orders/{id}", (int id) => Results.Ok(new { id }))
   .WithValidation<GetOrderRequest>();

app.Run();
```

## Configuration

No additional configuration required. Uses framework JSON settings automatically.

## Dependencies

- `Headless.Api`
- `Asp.Versioning.Http`
- `Microsoft.EntityFrameworkCore`

## Side Effects

- Configures `JsonOptions` for Minimal APIs

---

# Headless.Api.Mvc


Framework integration for ASP.NET Core MVC/Web API with controllers, filters, JSON configuration, and common utilities.

## Problem Solved

Provides consistent MVC configuration, base controllers, exception filters, and URL canonicalization for traditional controller-based APIs.

## Key Features

- `ApiControllerBase` - Base controller with common utilities
- `MvcApiExceptionFilter` - Standardized exception handling
- `MvcProblemDetailsNormalizer` - Consistent problem details formatting
- Environment-based action filters (`BlockInEnvironmentAttribute`, `RequireEnvironmentAttribute`)
- URL canonicalization middleware (`RedirectToCanonicalUrlRule`)
- Pre-configured JSON and MVC options
- API versioning integration with API Explorer

## Installation

```bash
dotnet add package Headless.Api.Mvc
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.AddHeadlessApi().ConfigureHeadlessMvc();
builder.Services.AddControllers();

var app = builder.Build();

app.MapControllers();
app.Run();
```

### Controller Example

```csharp
[ApiController]
[Route("api/[controller]")]
public sealed class OrdersController : ApiControllerBase
{
    [HttpGet("{id:int}")]
    public async Task<IActionResult> GetAsync(int id, CancellationToken ct)
    {
        var order = await _service.GetAsync(id, ct).AnyContext();
        return order is null ? NotFound() : Ok(order);
    }
}
```

## Configuration

No additional configuration required.

## Dependencies

- `Headless.Api`
- `Asp.Versioning.Mvc`
- `Asp.Versioning.Mvc.ApiExplorer`
- `Microsoft.EntityFrameworkCore`

## Side Effects

- Configures `MvcOptions` and `JsonOptions` for controllers
- Registers `MvcProblemDetailsNormalizer` singleton

---

# Headless.Api


Core ASP.NET Core API infrastructure providing service registration, middleware, security, JWT handling, and common API utilities.

## Problem Solved

Consolidates repetitive ASP.NET Core API setup (compression, security headers, problem details, JWT, identity, validation) into a single cohesive registration, ensuring consistent configuration across all API projects.

## Key Features

- One-call service registration via `AddHeadlessApi()`
- Response compression (Brotli, Gzip) with optimized settings
- Problem details standardization
- JWT token factory and claims principal handling
- HSTS security configuration
- API versioning integration
- Device detection
- Idempotency middleware
- Server timing middleware
- Request cancellation handling
- Diagnostic listeners for debugging

## Installation

```bash
dotnet add package Headless.Api
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Configure global settings (regex timeout, FluentValidation, JWT)
ApiRegistration.ConfigureGlobalSettings();

// Register all framework API services
builder.AddHeadlessApi();

var app = builder.Build();

// Optional: Add diagnostic listeners for debugging
using var _ = app.AddHeadlessApiDiagnosticListeners();

app.UseResponseCompression();
app.UseHsts();

app.Run();
```

## Configuration

### String Hashing (required)

```json
{
  "StringHash": {
    "Secret": "your-secret-key-min-32-chars-long"
  }
}
```

### String Encryption (required)

```json
{
  "StringEncryption": {
    "Key": "your-encryption-key"
  }
}
```

## Dependencies

- `Headless.Api.Abstractions`
- `Headless.BuildingBlocks`
- `Headless.Caching.Abstractions`
- `Headless.FluentValidation`
- `Headless.Api.FluentValidation`
- `Headless.Hosting`
- `Asp.Versioning.Http`
- `DeviceDetector.NET`
- `FluentValidation`
- `Mediator.Abstractions`
- `Microsoft.AspNetCore.OpenApi`
- `Microsoft.Extensions.Http.Resilience`
- `NetEscapades.AspNetCore.SecurityHeaders`

## Side Effects

- Registers `HttpContextAccessor`
- Configures response compression providers
- Configures route options (lowercase URLs)
- Configures form options (file upload limits)
- Configures HSTS options
- Adds resilience handler to `HttpClient` defaults

---

# Headless.Base


Foundational utility library providing extension methods, primitives, helpers, and common abstractions used throughout the framework.

## Problem Solved

Eliminates repetitive utility code across projects by providing a comprehensive set of battle-tested extensions, helpers, and primitives for common operations (strings, collections, dates, IO, reflection, etc.).

## Key Features

- **Result Pattern**: `Result<T>`, `DataResult<T>`, `NoDataResult` for exception-free control flow
- **Error Handling**: `ErrorDescriptor` for standardized error reporting
- **Domain Value Objects**: `GeoCoordinate`, `Currency`, `Range<T>`
- **Pagination**: `IndexPageRequest`/`ContinuationPageRequest` and response models
- **Collections**: `ForEachAsync`, `ParallelForEachAsync`, `Batch`, `DistinctBy`, and more
- **Dates & Time**: Fluent date manipulation, `TimeProvider` extensions, timezone conversion
- **Strings**: Humanize integration, manipulation helpers, high-performance toolkit
- **Reflection**: Fast property accessors, type scanning helpers
- **ID Generation**: `SnowflakeId`, `SequentialGuid`
- **Validation**: `MobilePhoneNumberValidator`, `GeoCoordinateValidator`, `EmailValidator`, `EgyptianNationalIdValidator`

## Installation

```bash
dotnet add package Headless.Base
```

## Quick Start

### Result Pattern

```csharp
public async Task<DataResult<User>> GetUserAsync(Guid id)
{
    var user = await _repo.GetByIdAsync(id);
    if (user is null)
        return DataResult<User>.Failure(new ErrorDescriptor("UserNotFound", "User does not exist"));

    return DataResult<User>.Success(user);
}
```

### Collection Extensions

```csharp
await users.ParallelForEachAsync(
    async user => await ProcessUserAsync(user),
    maxDegreeOfParallelism: 5
);
```

### Egyptian National ID Validator

```csharp
if (EgyptianNationalIdValidator.IsValid("29901011234567"))
{
    var info = EgyptianNationalIdValidator.Analyze("29901011234567");
    var birthDate = info.BirthDate;
    var governorate = info.Governorate;
}
```

## Configuration

No configuration required.

## Dependencies

- `Headless.Checks`
- `CommunityToolkit.HighPerformance`
- `Flurl`
- `Humanizer.Core`
- `IdGen`
- `libphonenumber-csharp`
- `morelinq`
- `Nito.AsyncEx`
- `Nito.Disposables`
- `Polly.Core`
- `System.Reactive`
- `TimeZoneConverter`
- `ZString`

## Side Effects

None.

---

# Headless.Blobs.Abstractions


Defines the unified interface for blob/file storage operations across different providers (AWS S3, Azure Blob, FileSystem, Redis, SFTP).

## Problem Solved

Provides a provider-agnostic API for file storage operations, enabling seamless switching between cloud providers or local storage without changing application code.

## Key Features

- `IBlobStorage` - Core interface for all storage operations:
  - Upload/Download blobs with metadata
  - Bulk upload/delete operations
  - Copy/Rename/Delete operations
  - Exists check and blob info retrieval
  - Paged listing with search patterns
- `IBlobNamingNormalizer` - Provider-specific path normalization
- Container/directory management
- Metadata support

## Installation

```bash
dotnet add package Headless.Blobs.Abstractions
```

## Usage

```csharp
public sealed class FileService(IBlobStorage storage)
{
    public async Task UploadAsync(Stream file, string fileName, CancellationToken ct)
    {
        await storage.UploadAsync(
            container: ["uploads", "images"],
            blobName: fileName,
            stream: file,
            metadata: new Dictionary<string, string?> { ["uploaded-by"] = "user-123" },
            cancellationToken: ct
        );
    }

    public async Task<Stream?> DownloadAsync(string fileName, CancellationToken ct)
    {
        var result = await storage.DownloadAsync(["uploads", "images"], fileName, ct);
        return result?.Stream;
    }
}
```

## Configuration

No configuration required. This is an abstractions-only package.

## Dependencies

- `Headless.Base`
- `Headless.Serializer.Json`

## Side Effects

None. This is an abstractions package.

---

# Headless.Blobs.Aws


AWS S3 implementation of the `IBlobStorage` interface for storing files in Amazon S3.

## Problem Solved

Provides seamless integration with AWS S3 for blob storage using the unified `IBlobStorage` abstraction.

## Key Features

- Full `IBlobStorage` implementation for AWS S3
- Bulk upload/delete with optimized batching
- Automatic path normalization for S3 object keys
- Metadata support
- Pre-signed URL generation capability
- Integration with AWS SDK configuration

## Installation

```bash
dotnet add package Headless.Blobs.Aws
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Option 1: Use configuration-based AWS options
var awsOptions = builder.Configuration.GetAWSOptions();
builder.Services.AddAwsS3BlobStorage(awsOptions, options =>
{
    options.BucketName = "my-bucket";
});

// Option 2: Manual configuration
builder.Services.AddAwsS3BlobStorage(new AWSOptions
{
    Region = RegionEndpoint.USEast1,
    Credentials = new BasicAWSCredentials("access-key", "secret-key")
}, options =>
{
    options.BucketName = "my-bucket";
});
```

## Configuration

### appsettings.json

```json
{
  "AWS": {
    "Region": "us-east-1",
    "AccessKey": "your-access-key",
    "SecretKey": "your-secret-key"
  }
}
```

### Options

```csharp
options.BucketName = "my-bucket";
```

## Dependencies

- `Headless.Blobs.Abstractions`
- `Headless.BuildingBlocks`
- `Headless.Hosting`
- `AWSSDK.S3`
- `AWSSDK.Extensions.NETCore.Setup`

## Side Effects

- Registers `IAmazonS3` if not already registered
- Registers `IBlobStorage` as singleton
- Registers `IBlobNamingNormalizer` as singleton

---

# Headless.Blobs.Azure


Azure Blob Storage implementation of the `IBlobStorage` interface for storing files in Azure.

## Problem Solved

Provides seamless integration with Azure Blob Storage using the unified `IBlobStorage` abstraction.

## Key Features

- Full `IBlobStorage` implementation for Azure Blob Storage
- Bulk operations with Azure Batch API
- Container management
- Metadata support
- Integration with Azure.Identity for authentication

## Installation

```bash
dotnet add package Headless.Blobs.Azure
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddAzureBlobStorage(options =>
{
    options.ConnectionString = builder.Configuration["Azure:Storage:ConnectionString"];
    options.ContainerName = "my-container";
});

// Or with Azure.Identity
builder.Services.AddAzureBlobStorage(options =>
{
    options.AccountName = "mystorageaccount";
    options.ContainerName = "my-container";
    // Uses DefaultAzureCredential
});
```

## Configuration

### appsettings.json

```json
{
  "Azure": {
    "Storage": {
      "ConnectionString": "DefaultEndpointsProtocol=https;AccountName=...;AccountKey=...;EndpointSuffix=core.windows.net",
      "ContainerName": "my-container"
    }
  }
}
```

## Dependencies

- `Headless.Blobs.Abstractions`
- `Headless.BuildingBlocks`
- `Headless.Hosting`
- `Azure.Storage.Blobs`
- `Azure.Storage.Blobs.Batch`
- `Microsoft.Extensions.Azure`

## Side Effects

- Registers `BlobServiceClient` via Azure client factory
- Registers `IBlobStorage` as singleton
- Registers `IBlobNamingNormalizer` as singleton

---

# Headless.Blobs.FileSystem


Local file system implementation of the `IBlobStorage` interface for development and on-premises scenarios.

## Problem Solved

Provides local file system storage using the unified `IBlobStorage` abstraction, ideal for development, testing, and on-premises deployments without cloud dependencies.

## Key Features

- Full `IBlobStorage` implementation using local file system
- Container mapping to directories
- Metadata stored as companion JSON files
- No external service dependencies
- Cross-platform path handling

## Installation

```bash
dotnet add package Headless.Blobs.FileSystem
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddFileSystemBlobStorage(options =>
{
    options.BasePath = Path.Combine(builder.Environment.ContentRootPath, "storage");
});
```

## Configuration

### appsettings.json

```json
{
  "FileSystemBlob": {
    "BasePath": "/var/data/blobs"
  }
}
```

### Options

```csharp
options.BasePath = "/path/to/storage";
```

## Dependencies

- `Headless.Blobs.Abstractions`
- `Headless.Hosting`

## Side Effects

- Registers `IBlobStorage` as singleton
- Creates the base directory if it doesn't exist

---

# Headless.Blobs.Redis


Redis implementation of the `IBlobStorage` interface for caching small blobs in Redis.

## Problem Solved

Provides high-speed blob storage for small files using Redis, suitable for temporary files, cache data, or session-related binary content.

## Key Features

- Full `IBlobStorage` implementation using Redis
- Suitable for small-to-medium sized blobs
- Fast read/write performance
- Automatic key expiration support
- Metadata stored alongside blobs

## Installation

```bash
dotnet add package Headless.Blobs.Redis
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRedisBlobStorage(options =>
{
    options.ConnectionString = "localhost:6379";
    options.KeyPrefix = "blobs:";
});
```

## Configuration

### appsettings.json

```json
{
  "RedisBlob": {
    "ConnectionString": "localhost:6379,password=secret",
    "KeyPrefix": "blobs:"
  }
}
```

## Dependencies

- `Headless.Blobs.Abstractions`
- `Headless.BuildingBlocks`
- `Headless.Hosting`
- `StackExchange.Redis`

## Side Effects

- Registers `IBlobStorage` as singleton
- Requires Redis connection (uses existing `IConnectionMultiplexer` if registered)

---

# Headless.Blobs.SshNet


SFTP/SSH implementation of the `IBlobStorage` interface for storing files on remote servers via SFTP.

## Problem Solved

Provides blob storage via SFTP/SSH protocol for scenarios requiring file transfer to remote servers, legacy system integration, or secure file exchange.

## Key Features

- Full `IBlobStorage` implementation using SFTP
- SSH key and password authentication
- Remote directory management
- Metadata support via companion files
- Connection pooling

## Installation

```bash
dotnet add package Headless.Blobs.SshNet
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddSshNetBlobStorage(options =>
{
    options.Host = "sftp.example.com";
    options.Port = 22;
    options.Username = "user";
    options.Password = "password"; // Or use PrivateKeyPath
    options.BasePath = "/home/user/uploads";
});
```

## Configuration

### appsettings.json

```json
{
  "SftpBlob": {
    "Host": "sftp.example.com",
    "Port": 22,
    "Username": "user",
    "Password": "secret",
    "BasePath": "/home/user/uploads"
  }
}
```

### SSH Key Authentication

```json
{
  "SftpBlob": {
    "Host": "sftp.example.com",
    "Username": "user",
    "PrivateKeyPath": "/path/to/key",
    "PrivateKeyPassphrase": "optional-passphrase"
  }
}
```

## Dependencies

- `Headless.Blobs.Abstractions`
- `Headless.Hosting`
- `SSH.NET`

## Side Effects

- Registers `IBlobStorage` as singleton
- Opens SSH/SFTP connections to remote server

---

# Headless.BuildingBlocks


Core abstractions and primitives for building domain-driven applications with multi-tenancy, user context, and cross-cutting concerns.

## Problem Solved

Provides standardized interfaces for common cross-cutting concerns (clock, user, tenant, locale, encryption) and domain primitives (UserId, AccountId, Money, PhoneNumber) enabling consistent patterns across all application layers.

## Key Features

- **Abstractions**:
  - `IClock` - Testable time abstraction
  - `ICurrentUser` - Current authenticated user context
  - `ICurrentTenant` - Multi-tenancy support
  - `ICurrentLocale` - Localization context
  - `ICurrentTimeZone` - Timezone handling
  - `IGuidGenerator` / `ILongIdGenerator` - ID generation
  - `IStringEncryptionService` / `IStringHashService` - Security utilities
  - `IPasswordGenerator` - Secure password generation
  - `ICancellationTokenProvider` - Cancellation token access

- **Primitives** (Source-generated with JSON/TypeConverter support):
  - `UserId` - Strongly-typed user identifier
  - `AccountId` - Strongly-typed account identifier
  - `Money` - Currency-aware decimal wrapper
  - `Month` - Month representation
  - `PhoneNumber` - E.164 phone number
  - `Image` / `File` - Media metadata
  - `PageMetadata` - SEO metadata
  - `TenantInformation` - Tenant data

- **Constants**: JWT claim types, authentication constants, user claim types

## Installation

```bash
dotnet add package Headless.BuildingBlocks
```

## Quick Start

```csharp
public sealed class OrderService(IClock clock, ICurrentUser user, ICurrentTenant tenant)
{
    public Order CreateOrder(CreateOrderRequest request)
    {
        return new Order
        {
            Id = Guid.NewGuid(),
            UserId = user.UserId!.Value,
            TenantId = tenant.Id,
            CreatedAt = clock.UtcNow,
            Total = new Money(request.Amount, request.Currency)
        };
    }
}
```

## Configuration

No configuration required. Implementations are registered by `Headless.Api` or other host packages.

## Dependencies

- `Headless.Checks`
- `Headless.Base`
- `Headless.Domains`
- `Headless.Serializer.Json`
- `Headless.Generator.Primitives` (source generator)
- `FluentValidation`
- `Microsoft.Extensions.Logging.Abstractions`
- `Snappier`

## Side Effects

None. This is an abstractions/primitives package.

---

# Headless.Caching.Abstractions


Defines the unified caching interface for both in-memory and distributed cache implementations.

## Problem Solved

Provides a provider-agnostic caching API, enabling seamless switching between memory and Redis caches without changing application code.

## Key Features

- `ICache` - Core interface for all cache operations:
  - Upsert/Get/Remove with expiration
  - Bulk operations (UpsertAll, GetAll, RemoveAll)
  - Prefix-based operations (GetByPrefix, RemoveByPrefix)
  - Atomic operations (TryInsert, TryReplace, Increment, SetIfHigher/Lower)
  - Set operations (SetAdd, SetRemove, GetSet)
- `IInMemoryCache` - Marker interface for in-memory implementations
- `IDistributedCache` - Marker interface for distributed implementations
- `ICache<T>` - Strongly-typed cache wrapper
- `CacheValue<T>` - Cache result with HasValue semantics

## Installation

```bash
dotnet add package Headless.Caching.Abstractions
```

## Usage

```csharp
public sealed class ProductService(ICache cache)
{
    public async Task<Product?> GetProductAsync(int id, CancellationToken ct)
    {
        var key = $"product:{id}";
        var cached = await cache.GetAsync<Product>(key, ct).AnyContext();

        if (cached.HasValue)
            return cached.Value;

        var product = await _repository.GetAsync(id, ct).AnyContext();
        if (product is not null)
            await cache.UpsertAsync(key, product, TimeSpan.FromMinutes(10), ct).AnyContext();

        return product;
    }
}
```

## Configuration

No configuration required. This is an abstractions-only package.

## Dependencies

None.

## Side Effects

None. This is an abstractions package.

---

# Headless.Caching.Memory


In-memory cache implementation for single-instance applications.

## Problem Solved

Provides high-performance in-memory caching using the unified `ICache` abstraction, suitable for single-instance deployments or as an L1 cache layer.

## Key Features

- Full `IInMemoryCache` implementation
- Can serve as default `ICache` or alongside distributed cache
- Supports strongly-typed `ICache<T>` pattern
- Automatic memory management with configurable limits
- Can act as `IDistributedCache` adapter for single-instance scenarios

## Installation

```bash
dotnet add package Headless.Caching.Memory
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// As default cache
builder.Services.AddInMemoryCache();

// Or with options
builder.Services.AddInMemoryCache(options =>
{
    options.MaxItems = 10000;
});

// As non-default (use alongside distributed cache)
builder.Services.AddInMemoryCache(isDefault: false);
```

## Configuration

### Options

```csharp
options.MaxItems = 10000;            // Maximum cached items
options.ShouldCloneValues = false;   // Clone values on get/set
```

## Dependencies

- `Headless.Caching.Abstractions`
- `Headless.Hosting`

## Side Effects

- Registers `IInMemoryCache` as singleton
- Registers `ICache` as singleton (if isDefault: true)
- Registers `IDistributedCache` adapter (if isDefault: true)
- Registers `ICache<T>` and `IInMemoryCache<T>` as singletons

---

# Headless.Caching.Redis


Redis distributed cache implementation for multi-instance applications.

## Problem Solved

Provides distributed caching using Redis via the unified `ICache` abstraction, enabling cache sharing across multiple application instances.

## Key Features

- Full `IDistributedCache` implementation
- Built on StackExchange.Redis
- Supports strongly-typed `IDistributedCache<T>` pattern
- Prefix-based key management
- Atomic operations (increment, compare-and-swap)
- Set operations

## Installation

```bash
dotnet add package Headless.Caching.Redis
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Option 1: Use connection string
builder.Services.AddRedisCaching(options =>
{
    options.ConnectionString = "localhost:6379";
});

// Option 2: Use existing IConnectionMultiplexer
builder.Services.AddRedisCaching();
```

## Configuration

### appsettings.json

```json
{
  "Redis": {
    "ConnectionString": "localhost:6379,password=secret,ssl=true"
  }
}
```

### Options

```csharp
options.ConnectionString = "localhost:6379";
options.KeyPrefix = "myapp:";
```

## Dependencies

- `Headless.Caching.Abstractions`
- `Headless.Hosting`
- `Headless.Redis`
- `Headless.Serializer.Json`

## Side Effects

- Registers `IDistributedCache` as singleton
- Registers `IDistributedCache<T>` as singleton
- Uses existing `IConnectionMultiplexer` if registered, otherwise creates one

---

# Headless.Checks


Guard clause library for argument validation and defensive programming.

## Problem Solved

Provides a fluent, expressive API for validating method arguments and ensuring preconditions, eliminating boilerplate validation code and standardizing error messages.

## Key Features

- **Argument Validation**: Extensive static methods on `Argument` class
- **Runtime Assertions**: `Ensure` class for internal state validation
- **Performance Optimized**: `AggressiveInlining` and `DebuggerStepThrough`
- **Caller Expression Support**: Automatic parameter name capture
- **Type Support**: Nullable, `Span<T>`, `ReadOnlySpan<T>`, collections, strings

## Installation

```bash
dotnet add package Headless.Checks
```

## Quick Start

### Argument Validation

```csharp
using Headless.Checks;

public void CreateUser(string name, int age, List<string> roles)
{
    Argument.IsNotNullOrEmpty(name);
    Argument.IsPositive(age);
    Argument.IsNotNullOrEmpty(roles);
    Argument.HasNoNulls(roles);
}
```

### Common Checks

- `Argument.IsNotNull(value)`
- `Argument.IsNotNullOrEmpty(string|collection)`
- `Argument.IsNotNullOrWhiteSpace(string)`
- `Argument.IsPositive(number)` / `IsNegative` / `IsPositiveOrZero` / `IsNegativeOrZero`
- `Argument.IsOneOf(value, allowedValues)`
- `Argument.IsInEnum(enumValue)`
- `Argument.HasNoNulls(collection)`
- `Argument.FileExists(path)` / `DirectoryExists(path)`

### Runtime Assertions

```csharp
using Headless.Checks;

public void ProcessOrder()
{
    Ensure.True(_initialized, "Service must be initialized.");
    Ensure.NotDisposed(_disposed, this);
    Ensure.False(_queue.IsEmpty, "Queue should not be empty.");
}
```

## Configuration

No configuration required.

## Dependencies

None.

## Side Effects

None.

---



DI-based implementation of `ILocalMessagePublisher` for in-process domain event handling.

## Problem Solved

Provides in-memory local message publishing that resolves handlers from the DI container, enabling decoupled event-driven architecture within a single process.

## Key Features

- `ILocalMessagePublisher` implementation using DI
- Automatic handler discovery and resolution
- Handler ordering via `LocalEventHandlerOrderAttribute`
- Sync and async publishing support
- Scoped handler resolution

## Installation

```bash
dotnet add package Headless.Domains.LocalMessagePublisher.DI
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Register local message publisher
builder.Services.AddLocalMessagePublisher();

// Register handlers (automatically discovered or explicit)
builder.Services.AddScoped<ILocalMessageHandler<OrderCreatedEvent>, OrderCreatedHandler>();
```

### Publishing Events

```csharp
public sealed class OrderService(ILocalMessagePublisher publisher)
{
    public async Task CreateOrderAsync(Order order, CancellationToken ct)
    {
        await _repository.AddAsync(order, ct).AnyContext();

        await publisher.PublishAsync(new OrderCreatedEvent(order.Id), ct).AnyContext();
    }
}
```

### Handling Events

```csharp
public sealed class OrderCreatedHandler : ILocalMessageHandler<OrderCreatedEvent>
{
    public async Task HandleAsync(OrderCreatedEvent message, CancellationToken ct)
    {
        // Send email, update read model, etc.
    }
}

[LocalEventHandlerOrder(1)] // Execute first
public sealed class AuditHandler : ILocalMessageHandler<OrderCreatedEvent>
{
    public Task HandleAsync(OrderCreatedEvent message, CancellationToken ct)
    {
        // Audit logging
        return Task.CompletedTask;
    }
}
```

## Configuration

No configuration required.

## Dependencies

- `Headless.Domains`
- `Headless.Hosting`

## Side Effects

- Registers `ILocalMessagePublisher` as scoped

---


# Headless.Emails.Abstractions


Defines the unified interface for sending emails across different providers (AWS SES, SMTP/MailKit, development).

## Problem Solved

Provides a provider-agnostic email sending API, enabling seamless switching between email providers without changing application code.

## Key Features

- `IEmailSender` - Core interface for sending emails
- `SendSingleEmailRequest` - Request model with recipients, subject, body, attachments
- `SendSingleEmailResponse` - Response with success status and message ID

## Installation

```bash
dotnet add package Headless.Emails.Abstractions
```

## Usage

```csharp
public sealed class NotificationService(IEmailSender emailSender)
{
    public async Task SendWelcomeEmailAsync(string to, string name, CancellationToken ct)
    {
        var response = await emailSender.SendAsync(new SendSingleEmailRequest
        {
            To = [to],
            Subject = "Welcome!",
            HtmlBody = $"<h1>Hello {name}!</h1>",
            TextBody = $"Hello {name}!"
        }, ct).AnyContext();

        if (!response.IsSuccess)
            _logger.LogError("Failed to send email: {Error}", response.Error);
    }
}
```

## Configuration

No configuration required. This is an abstractions-only package.

## Dependencies

None.

## Side Effects

None.

---

# Headless.Emails.Aws


AWS SES (Simple Email Service) v2 implementation of the email sending abstraction.

## Problem Solved

Provides email sending via AWS SES using the unified `IEmailSender` abstraction, ideal for production deployments on AWS.

## Key Features

- Full `IEmailSender` implementation using AWS SES v2
- High deliverability and scalability
- AWS SDK configuration integration
- Attachment support

## Installation

```bash
dotnet add package Headless.Emails.Aws
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Using configuration
var awsOptions = builder.Configuration.GetAWSOptions();
builder.Services.AddAwsSesEmailSender(awsOptions);

// Or using explicit options
builder.Services.AddAwsSesEmailSender(new AWSOptions
{
    Region = RegionEndpoint.USEast1,
    Credentials = new BasicAWSCredentials("accessKey", "secretKey")
});
```

## Configuration

### appsettings.json

```json
{
  "AWS": {
    "Region": "us-east-1"
  }
}
```

## Dependencies

- `Headless.Emails.Core`
- `AWSSDK.SimpleEmailV2`
- `AWSSDK.Extensions.NETCore.Setup`

## Side Effects

- Registers `IAmazonSimpleEmailServiceV2` if not already registered
- Registers `IEmailSender` as singleton

---

# Headless.Emails.Core


Core utilities and MimeKit integration for email implementations.

## Problem Solved

Provides shared conversion logic to bridge framework email contracts with MimeKit, eliminating duplication across email provider implementations.

## Key Features

- `MimeMessage` conversion from `SendSingleEmailRequest`
- Address mapping (To, From, Cc, Bcc)
- Body building (Text/HTML)
- Attachment handling

## Installation

```bash
dotnet add package Headless.Emails.Core
```

## Usage

```csharp
// Convert framework request to MimeKit message
MimeMessage message = await request.ConvertToMimeMessageAsync(cancellationToken);
```

## Configuration

No configuration required.

## Dependencies

- `Headless.Emails.Abstractions`
- `Headless.Hosting`
- `MailKit`

## Side Effects

None. This is a utility package.

---

# Headless.Emails.Dev


Development email implementations for local testing and debugging.

## Problem Solved

Provides safe email implementations for development/testing that don't send real emails, preventing accidental sends and enabling easy inspection of email content.

## Key Features

- `DevEmailSender` - Writes full email content to a local file
- `NoopEmailSender` - Discards emails silently
- No network calls required
- Easy inspection of email content

## Installation

```bash
dotnet add package Headless.Emails.Dev
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

if (builder.Environment.IsDevelopment())
{
    builder.Services.AddDevEmailSender("path/to/emails.txt");
}
```

## Output Format

The `DevEmailSender` appends to the file with a separator:

```text
From: sender@example.com
To: recipient@example.com
Subject: Test Email
Message:
Hello World!
--------------------
```

## Configuration

### Options

```csharp
services.AddDevEmailSender("emails.txt"); // Path to output file
```

## Dependencies

- `Headless.Emails.Abstractions`
- `Headless.Hosting`

## Side Effects

- Registers `IEmailSender` as singleton
- Writes emails to specified file

---

# Headless.Emails.Mailkit


SMTP implementation of the email abstraction using MailKit.

## Problem Solved

Provides email sending via standard SMTP protocol using MailKit, supporting any SMTP server (Gmail, Outlook, SendGrid, on-premises, etc.).

## Key Features

- Full `IEmailSender` implementation using MailKit
- SSL/TLS support (StartTls, SslOnConnect)
- Authentication support
- Attachment support
- Works with any SMTP server

## Installation

```bash
dotnet add package Headless.Emails.Mailkit
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Using IConfiguration
builder.Services.AddMailKitEmailSender(builder.Configuration.GetSection("Smtp"));

// Or using action
builder.Services.AddMailKitEmailSender(options =>
{
    options.Server = "smtp.example.com";
    options.Port = 587;
    options.User = "user@example.com";
    options.Password = "securepassword";
    options.SocketOptions = SecureSocketOptions.StartTls;
});
```

## Configuration

### appsettings.json

```json
{
  "Smtp": {
    "Server": "smtp.example.com",
    "Port": 587,
    "User": "user@example.com",
    "Password": "securepassword",
    "SocketOptions": "StartTls"
  }
}
```

### Options (`MailkitSmtpOptions`)

| Property | Description |
|----------|-------------|
| `Server` | SMTP server hostname (required) |
| `Port` | SMTP port (default: 25) |
| `User` | Authentication username |
| `Password` | Authentication password |
| `SocketOptions` | `SecureSocketOptions` (StartTls, SslOnConnect) |

## Dependencies

- `Headless.Emails.Core`

## Side Effects

- Registers `IEmailSender` as singleton

---

# Headless.Features.Abstractions


Defines the unified interface for feature management and feature flags across different storage providers.

## Problem Solved

Provides a provider-agnostic feature management API, enabling dynamic feature toggling with support for multi-tenancy, editions, and hierarchical feature values without changing application code.

## Key Features

- `IFeatureManager` - Core interface for getting/setting feature values
- `IFeatureDefinitionProvider` - Define features in code
- `IFeatureDefinitionManager` - Manage feature definitions
- Feature value providers (Default, Edition, Tenant)
- `RequiresFeatureAttribute` - Attribute-based feature gating
- Hierarchical feature definitions with groups

## Installation

```bash
dotnet add package Headless.Features.Abstractions
```

## Usage

```csharp
public sealed class BillingService(IFeatureManager features)
{
    public async Task ProcessAsync(CancellationToken ct)
    {
        var maxUsers = await features.GetAsync("MaxUsers", cancellationToken: ct).AnyContext();

        if (int.Parse(maxUsers.Value ?? "10") > 100)
        {
            // Premium feature logic
        }
    }
}
```

### Defining Features

```csharp
public class MyFeatureDefinitionProvider : IFeatureDefinitionProvider
{
    public void Define(IFeatureDefinitionContext context)
    {
        var group = context.AddGroup("App.Features");

        group.AddFeature("MaxUsers", defaultValue: "10");
        group.AddFeature("EnableReports", defaultValue: "false");
    }
}
```

## Configuration

No configuration required. This is an abstractions-only package.

## Dependencies

None.

## Side Effects

None.

---

# Headless.Features.Core


Core implementation of feature management with caching, value providers, and definition management.

## Problem Solved

Provides the full feature management implementation including hierarchical value resolution (Tenant > Edition > Default), caching, background initialization, and extensible value providers.

## Key Features

- `FeatureManager` - Full implementation of `IFeatureManager`
- Value providers: Default, Edition, Tenant
- Static and dynamic feature definition stores
- Feature value caching with invalidation
- Background service for feature initialization
- Method invocation feature checking

## Installation

```bash
dotnet add package Headless.Features.Core
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Requires: TimeProvider, ICache, IResourceLock, IGuidGenerator
builder.Services.AddFeaturesManagementCore(options =>
{
    options.CacheKeyPrefix = "features:";
});

// Register feature definition providers
builder.Services.AddFeatureDefinitionProvider<MyFeatureDefinitionProvider>();

// Add storage (e.g., Entity Framework)
builder.Services.AddFeaturesManagementDbContextStorage<AppDbContext>();
```

### Custom Value Provider

```csharp
builder.Services.AddFeatureValueProvider<CustomFeatureValueProvider>();
```

## Configuration

### Options

```csharp
services.AddFeaturesManagementCore(options =>
{
    options.CacheKeyPrefix = "features:";  // Cache key prefix
});
```

## Dependencies

- `Headless.Features.Abstractions`
- `Headless.Domains`
- `Headless.Caching.Abstractions`
- `Headless.ResourceLocks.Abstractions`

## Side Effects

- Registers `IFeatureManager` as transient
- Registers feature stores as singletons
- Starts `FeaturesInitializationBackgroundService` hosted service
- Registers cache invalidation handler for feature value changes

---

# Headless.Features.Storage.EntityFramework


Entity Framework Core storage implementation for feature management.

## Problem Solved

Provides persistent storage for feature definitions and values using Entity Framework Core, enabling database-backed feature management with full CRUD support.

## Key Features

- `IFeaturesDbContext` - DbContext interface for features
- `FeaturesDbContext` - Ready-to-use DbContext
- EF repositories for feature definitions and values
- Model builder extensions for custom DbContext integration
- Pooled DbContext factory support

## Installation

```bash
dotnet add package Headless.Features.Storage.EntityFramework
```

## Quick Start

### Using Built-in DbContext

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddFeaturesManagementDbContextStorage(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("Features"))
);
```

### Using Custom DbContext

```csharp
public class AppDbContext : DbContext, IFeaturesDbContext
{
    public DbSet<FeatureDefinitionRecord> FeatureDefinitions => Set<FeatureDefinitionRecord>();
    public DbSet<FeatureGroupDefinitionRecord> FeatureGroupDefinitions => Set<FeatureGroupDefinitionRecord>();
    public DbSet<FeatureValueRecord> FeatureValues => Set<FeatureValueRecord>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ConfigureFeatureManagement();
    }
}

// Registration
builder.Services.AddFeaturesManagementDbContextStorage<AppDbContext>();
```

## Configuration

No additional configuration required beyond DbContext setup.

## Dependencies

- `Headless.Features.Core`
- `Microsoft.EntityFrameworkCore`

## Side Effects

- Registers `IFeatureDefinitionRecordRepository` as singleton
- Registers `IFeatureValueRecordRepository` as singleton
- Uses pooled DbContext factory for performance

---

# Headless.FluentValidation


Extension library for FluentValidation providing enterprise-grade validators and utilities.

## Problem Solved

Provides a comprehensive suite of common validators (phone numbers, national IDs, URLs, pagination) and standardized error handling, eliminating the need to rewrite common validation logic across projects.

## Key Features

- Phone number validation (international, country-specific) via `libphonenumber-csharp`
- Egyptian National ID validation with checksum verification
- Collection validators (unique elements, min/max counts)
- Geo validators (latitude/longitude)
- Pagination validators (page index, page size, search query)
- URL validators (absolute URLs, HTTP/HTTPS)
- `ErrorDescriptor` integration for structured API responses
- Automatic camelCase property path normalization

## Installation

```bash
dotnet add package Headless.FluentValidation
```

## Quick Start

```csharp
using Headless.FluentValidation;

public sealed class UserValidator : AbstractValidator<User>
{
    public UserValidator()
    {
        RuleFor(x => x.PhoneNumber).InternationalPhoneNumber();
        RuleFor(x => x.Email).NotEmpty().EmailAddress();
        RuleFor(x => x.Roles).MinimumElements(1).UniqueElements();
    }
}
```

## Usage

### Phone Number Validation

```csharp
RuleFor(x => x.Phone).BasicPhoneNumber();                    // DataAnnotations check
RuleFor(x => x.Phone).PhoneNumber(u => u.CountryCode);       // Country-specific
RuleFor(x => x.Phone).InternationalPhoneNumber();            // International format
```

### Error Descriptor Integration

```csharp
RuleFor(x => x.Total).GreaterThan(0)
    .WithErrorDescriptor(new ErrorDescriptor("ORDER_TOTAL_INVALID", "Total must be positive."));
```

### Processing Validation Results

```csharp
var errors = result.Errors.ToErrorDescriptors(); // Dictionary<string, List<ErrorDescriptor>>
```

## Available Validators

| Category | Validators |
|----------|-----------|
| Phone | `BasicPhoneNumber`, `PhoneNumber`, `InternationalPhoneNumber`, `PhoneCountryCode` |
| National ID | `EgyptianNationalId` |
| Collection | `MaximumElements`, `MinimumElements`, `UniqueElements` |
| Geo | `Latitude`, `Longitude` |
| Pagination | `PageIndex`, `PageSize`, `SearchQuery` |
| URL | `Url`, `HttpUrl` |
| ID | `Id` (validates non-empty Guid, positive int/long) |

## Configuration

No configuration required.

## Dependencies

- `FluentValidation`
- `libphonenumber-csharp`
- `Headless.Base`

## Side Effects

None.

---

# Headless.Generator.Primitives.Abstractions


Abstractions and attributes for the domain primitives source generator.

## Problem Solved

Provides the runtime contracts and attributes needed to define strongly-typed domain primitives that work with the source generator, ensuring type safety and domain constraints at compile time.

## Key Features

- `IPrimitive<T>` - Core interface for domain primitives
- `PrimitiveValidationResult` - Validation result model
- Attributes for generator configuration:
  - `StringLengthAttribute` - Min/max length constraints
  - `SupportedOperationsAttribute` - Enable comparison, math operations
  - `SerializationFormatAttribute` - Custom serialization formats
  - `UnderlyingPrimitiveTypeAttribute` - Specify underlying type
- Helper extensions for DateOnly, XML serialization

## Installation

```bash
dotnet add package Headless.Generator.Primitives.Abstractions
```

## Quick Start

```csharp
using Headless.Generator.Primitives;

[StringLength(1, 100)]
public readonly partial struct ProductName : IPrimitive<string>
{
    public static PrimitiveValidationResult Validate(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            return PrimitiveValidationResult.Error("Name cannot be empty");

        return PrimitiveValidationResult.Ok;
    }
}
```

### With Supported Operations

```csharp
[SupportedOperations(Comparison = true, Math = true)]
public readonly partial struct Quantity : IPrimitive<int>
{
    public static PrimitiveValidationResult Validate(int value)
    {
        return value >= 0
            ? PrimitiveValidationResult.Ok
            : PrimitiveValidationResult.Error("Quantity cannot be negative");
    }
}
```

## Configuration

No configuration required. This is an abstractions-only package.

## Dependencies

None.

## Side Effects

None.

---

# Headless.Generator.Primitives


Roslyn source generator for creating strongly-typed domain primitives.

## Problem Solved

Automatically generates boilerplate code for domain primitives including constructors, equality, comparison, JSON serialization, Entity Framework value converters, TypeConverters, and OpenAPI schema mappings.

## Key Features

- Roslyn incremental source generator
- Generates for types implementing `IPrimitive<T>`
- Auto-generated code:
  - Constructors and factory methods
  - `IEquatable<T>`, `IComparable<T>` implementations
  - JSON converters (System.Text.Json)
  - Entity Framework Core value converters
  - TypeConverter for model binding
  - Dapper type handlers
  - NSwag/Swashbuckle schema mappings

## Installation

```bash
dotnet add package Headless.Generator.Primitives
```

## Quick Start

```csharp
// Define your primitive
[StringLength(1, 50)]
public readonly partial struct Email : IPrimitive<string>
{
    public static PrimitiveValidationResult Validate(string value)
    {
        if (!value.Contains('@'))
            return PrimitiveValidationResult.Error("Invalid email format");

        return PrimitiveValidationResult.Ok;
    }
}

// Generated code provides:
var email = Email.From("user@example.com");  // Factory method
var value = email.Value;                      // Underlying value
var json = JsonSerializer.Serialize(email);   // JSON: "user@example.com"
```

### Entity Framework Integration

```csharp
// Auto-generated value converter is registered via:
modelBuilder.Entity<User>()
    .Property(u => u.Email)
    .HasConversion<EmailValueConverter>();
```

## Configuration

### MSBuild Properties

```xml
<PropertyGroup>
  <PrimitiveGenerator_GenerateDapper>true</PrimitiveGenerator_GenerateDapper>
  <PrimitiveGenerator_GenerateEfCore>true</PrimitiveGenerator_GenerateEfCore>
  <PrimitiveGenerator_GenerateSwashbuckle>false</PrimitiveGenerator_GenerateSwashbuckle>
</PropertyGroup>
```

## Dependencies

- `Headless.Generator.Primitives.Abstractions`
- `Microsoft.CodeAnalysis.CSharp` (compile-time only)

## Side Effects

- Generates source files at compile time
- No runtime dependencies added

---

# Headless.Hosting


Core hosting utilities and extensions for ASP.NET Core applications.

## Problem Solved

Provides essential DI extensions, configuration helpers, options validation, and seeder infrastructure to reduce boilerplate in application startup and configuration.

## Key Features

- DI extensions: `AddIf`, `AddIfElse`, `AddOrReplace*`, `Unregister<T>`
- Options validation with FluentValidation
- Configuration binding extensions
- Environment detection extensions
- Database seeder infrastructure (`ISeeder`, `IPreSeeder`)
- Keyed services helpers
- Hosted service management

## Installation

```bash
dotnet add package Headless.Hosting
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Conditional registration
builder.Services.AddIf(
    builder.Environment.IsDevelopment(),
    s => s.AddDevEmailSender("emails.txt")
);

// Options with FluentValidation
builder.Services.AddOptionsWithFluentValidation<MyOptions, MyOptionsValidator>("MySection");

// Replace existing service
builder.Services.AddOrReplaceSingleton<IMyService, BetterMyService>();
```

## Usage

### Conditional Service Registration

```csharp
services.AddIf(condition, s => s.AddSingleton<IService, Impl>());
services.AddIfElse(condition, ifAction, elseAction);
```

### Options with Validation

```csharp
services.AddOptionsWithFluentValidation<AppOptions, AppOptionsValidator>("App");
```

### Database Seeders

```csharp
public class UserSeeder : ISeeder
{
    [SeederPriority(1)]
    public async Task SeedAsync(CancellationToken ct) { /* ... */ }
}

// In startup
await app.Services.RunSeedersAsync();
```

### Service Replacement

```csharp
services.AddOrReplaceScoped<IService, NewImpl>();
services.AddOrReplaceSingleton<IService>(sp => new Impl(sp.GetRequired<IDep>()));
```

## Configuration

No configuration required.

## Dependencies

- `Headless.Checks`
- `Microsoft.Extensions.Hosting`
- `Microsoft.Extensions.Options`

## Side Effects

None directly. Utilities for managing service registration.

---

# Headless.Identity.Storage.EntityFramework


Entity Framework Core integration for ASP.NET Core Identity with framework extensions.

## Problem Solved

Provides a pre-configured Identity DbContext base class with framework-specific extensions, enabling seamless integration of ASP.NET Core Identity with the framework's EF Core conventions and interceptors.

## Key Features

- `HeadlessIdentityDbContext<>` - Base DbContext with Identity support
- Framework EF extensions pre-configured
- Support for custom user, role, and claim types
- Flexible service lifetime configuration

## Installation

```bash
dotnet add package Headless.Identity.Storage.EntityFramework
```

## Quick Start

```csharp
public class AppDbContext : HeadlessIdentityDbContext<
    AppUser, AppRole, Guid,
    AppUserClaim, AppUserRole, AppUserLogin,
    AppRoleClaim, AppUserToken>
{
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }
}

// Registration
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHeadlessDbContext<
    AppDbContext,
    AppUser, AppRole, Guid,
    AppUserClaim, AppUserRole, AppUserLogin,
    AppRoleClaim, AppUserToken
>(options => options.UseNpgsql(connectionString));
```

## Configuration

No additional configuration required beyond DbContext options.

## Dependencies

- `Headless.Orm.EntityFramework`
- `Microsoft.AspNetCore.Identity.EntityFrameworkCore`

## Side Effects

- Registers DbContext with specified lifetime (default: Scoped)
- Adds framework EF extensions to DbContext options

---

# Headless.Imaging.Abstractions


Defines the unified interface for image processing operations.

## Problem Solved

Provides a provider-agnostic API for image resizing and compression, enabling seamless switching between image processing libraries without changing application code.

## Key Features

- `IImageResizer` - Interface for image resizing operations
- `IImageCompressor` - Interface for image compression operations
- `ImageResizeArgs` - Configuration for resize operations (dimensions, mode)
- `ImageCompressArgs` - Configuration for compression (quality, format)
- `ImageResizeMode` - Resize modes (Crop, Pad, Stretch, etc.)
- Result models with processing state information

## Installation

```bash
dotnet add package Headless.Imaging.Abstractions
```

## Usage

```csharp
public sealed class ImageService(IImageResizer resizer, IImageCompressor compressor)
{
    public async Task<Stream> ProcessAsync(Stream input, CancellationToken ct)
    {
        var resized = await resizer.ResizeAsync(input, new ImageResizeArgs
        {
            Width = 800,
            Height = 600,
            Mode = ImageResizeMode.Max
        }, ct).AnyContext();

        return resized.Stream;
    }
}
```

## Configuration

No configuration required. This is an abstractions-only package.

## Dependencies

None.

## Side Effects

None.

---

# Headless.Imaging.Core


Core image processing implementation with contributor-based extensibility.

## Problem Solved

Provides the orchestration layer for image processing, delegating to registered contributors (like ImageSharp) for actual processing while maintaining a unified API.

## Key Features

- `ImageResizer` - Orchestrates resize operations across contributors
- `ImageCompressor` - Orchestrates compression operations
- Contributor pattern for extensibility (`IImageResizerContributor`, `IImageCompressorContributor`)
- Builder pattern for fluent registration
- Options validation

## Installation

```bash
dotnet add package Headless.Imaging.Core
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services
    .AddImaging(options =>
    {
        options.DefaultQuality = 85;
    })
    .AddImageSharpContributors(); // From Headless.Imaging.ImageSharp
```

## Configuration

### Options

```csharp
services.AddImaging(options =>
{
    options.DefaultQuality = 85;        // Default compression quality
    options.MaxWidth = 4096;            // Maximum allowed width
    options.MaxHeight = 4096;           // Maximum allowed height
});
```

## Dependencies

- `Headless.Imaging.Abstractions`
- `Headless.Hosting`

## Side Effects

- Registers `IImageResizer` as singleton
- Registers `IImageCompressor` as singleton

---

# Headless.Imaging.ImageSharp


ImageSharp-based implementation for image resizing and compression.

## Problem Solved

Provides high-performance, cross-platform image processing using SixLabors.ImageSharp, supporting various formats and advanced resize/compression operations.

## Key Features

- `ImageSharpImageResizerContributor` - ImageSharp resize implementation
- `ImageSharpImageCompressorContributor` - ImageSharp compression implementation
- Support for JPEG, PNG, WebP, GIF formats
- Configurable encoder settings per format
- Memory-efficient processing

## Installation

```bash
dotnet add package Headless.Imaging.ImageSharp
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services
    .AddImaging()
    .AddImageSharpContributors(options =>
    {
        options.JpegQuality = 85;
        options.PngCompressionLevel = 6;
    });
```

## Configuration

### Options

```csharp
services.AddImaging()
    .AddImageSharpContributors(options =>
    {
        options.JpegQuality = 85;           // JPEG quality (1-100)
        options.PngCompressionLevel = 6;    // PNG compression (0-9)
        options.WebPQuality = 80;           // WebP quality (1-100)
    });
```

## Dependencies

- `Headless.Imaging.Core`
- `SixLabors.ImageSharp`

## Side Effects

- Registers `IImageResizerContributor` as singleton
- Registers `IImageCompressorContributor` as singleton

---

# Headless.Logging.Serilog


Serilog configuration factory with sensible defaults and structured logging setup.

## Problem Solved

Provides pre-configured Serilog logger configurations for bootstrap and production logging, with standard enrichers, output templates, and file/console sinks configured for typical application needs.

## Key Features

- Bootstrap logger configuration for startup errors
- Reloadable logger configuration from `IConfiguration`
- Standard enrichers: Environment, Thread, Process, Machine, Span
- File sinks with rolling (fatal, error, warning logs)
- Console sink with themed output
- Application version and commit hash enrichment

## Installation

```bash
dotnet add package Headless.Logging.Serilog
```

## Quick Start

```csharp
// Program.cs - Bootstrap logger
Log.Logger = SerilogFactory.CreateBootstrapLoggerConfiguration()
    .CreateLogger();

var builder = WebApplication.CreateBuilder(args);

// Production logger with configuration reload
builder.Host.UseSerilog((context, services, config) =>
    config.ConfigureReloadableLoggerConfiguration(
        services,
        context.Configuration,
        context.HostingEnvironment
    )
);
```

## Configuration

### appsettings.json

```json
{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    }
  }
}
```

## Dependencies

- `Headless.Base`
- `Serilog`
- `Serilog.AspNetCore`
- `Serilog.Enrichers.*`
- `Serilog.Sinks.Console`
- `Serilog.Sinks.File`

## Side Effects

- Writes log files to `Logs/` directory (fatal, error, warning)
- Console output with structured template

---

# Headless.Media.Indexing.Abstractions


Defines the interface for extracting text from media files for indexing.

## Problem Solved

Provides a unified API for extracting textual content from various document formats (PDF, Word, PowerPoint), enabling full-text search indexing of uploaded files.

## Key Features

- `IMediaFileTextProvider` - Interface for text extraction
- Stream-based API for memory efficiency
- Async support for large file processing

## Installation

```bash
dotnet add package Headless.Media.Indexing.Abstractions
```

## Usage

```csharp
public sealed class DocumentIndexer(IEnumerable<IMediaFileTextProvider> providers)
{
    public async Task<string> ExtractTextAsync(Stream fileStream, string mimeType)
    {
        var provider = providers.FirstOrDefault(p => p.SupportsMimeType(mimeType));
        if (provider is null) return string.Empty;

        return await provider.GetTextAsync(fileStream).AnyContext();
    }
}
```

## Configuration

No configuration required. This is an abstractions-only package.

## Dependencies

None.

## Side Effects

None.

---

# Headless.Media.Indexing


Text extraction implementations for common document formats.

## Problem Solved

Provides text extraction from PDF, Word (.docx), and PowerPoint (.pptx) documents for full-text search indexing, using industry-standard libraries.

## Key Features

- `PdfMediaFileTextProvider` - PDF text extraction via iText
- `WordDocumentMediaFileTextProvider` - Word document text extraction via Open XML
- `PresentationDocumentMediaFileTextProvider` - PowerPoint text extraction via Open XML
- Stream-based processing for memory efficiency

## Installation

```bash
dotnet add package Headless.Media.Indexing
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Register text providers
builder.Services.AddSingleton<IMediaFileTextProvider, PdfMediaFileTextProvider>();
builder.Services.AddSingleton<IMediaFileTextProvider, WordDocumentMediaFileTextProvider>();
builder.Services.AddSingleton<IMediaFileTextProvider, PresentationDocumentMediaFileTextProvider>();
```

## Usage

```csharp
public class SearchIndexer(PdfMediaFileTextProvider pdfProvider)
{
    public async Task IndexPdfAsync(Stream pdfStream)
    {
        var text = await pdfProvider.GetTextAsync(pdfStream).AnyContext();
        // Index extracted text...
    }
}
```

## Configuration

No configuration required.

## Dependencies

- `Headless.Media.Indexing.Abstractions`
- `itext7` (PDF)
- `DocumentFormat.OpenXml` (Word, PowerPoint)

## Side Effects

None.

---

# Headless.NetTopologySuite


NetTopologySuite extensions for geospatial operations and SQL Server geography compatibility.

## Problem Solved

Provides robust geometry manipulation utilities, precision handling, and SQL Server geography sanitization, solving common issues with geometry validity, coordinate orientation, and precision when working with geospatial data.

## Key Features

- Geometry precision reduction and management
- Permissive geometry operations (intersection, union, difference)
- SQL Server geography sanitization (ring orientation, validation)
- Polygon simplification with topology preservation
- Geometry creation helpers (points, polygons, multi-polygons)
- Coordinate range validation
- Feature collection conversion

## Installation

```bash
dotnet add package Headless.NetTopologySuite
```

## Quick Start

```csharp
using NetTopologySuite.Geometries;

var factory = new GeometryFactory(GeoConstants.HighPrecision, GeoConstants.GoogleMapsSrid);

// Create a polygon from coordinates
var polygon = factory.CreatePolygon(new[]
{
    new Coordinate(0, 0),
    new Coordinate(10, 0),
    new Coordinate(10, 10),
    new Coordinate(0, 10),
    new Coordinate(0, 0)
});

// Sanitize for SQL Server geography
var sanitized = polygon.SanitizeForSqlGeography();

// Simplify polygon
var simplified = polygon.Simplify(GeoConstants.Around1MDegrees);
```

## Usage

### Permissive Operations

```csharp
var intersection = geom1.PermissiveIntersection(geom2);
var union = geom1.PermissiveUnion(geom2);
var overlap = geom1.ComputeOverlap(geom2);
```

### Ring Orientation

```csharp
var fixed = polygon.EnsureIsOrientedCounterClockwise();
```

## Configuration

No configuration required.

## Dependencies

- `NetTopologySuite`
- `NetTopologySuite.Features`
- `Headless.Checks`

## Side Effects

None.

---

# Headless.OpenApi.Nswag.OData


NSwag operation filter for OData query parameter documentation.

## Problem Solved

Automatically documents OData query parameters ($filter, $orderby, $top, $skip, $select) in OpenAPI specifications for endpoints that support OData queries.

## Key Features

- `ODataOperationFilter` - Adds OData query parameters to OpenAPI docs
- Automatic parameter detection
- Standard OData parameter descriptions

## Installation

```bash
dotnet add package Headless.OpenApi.Nswag.OData
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHeadlessNswagOpenApi(
    setupHeadlessAction: null,
    setupGeneratorActions: settings =>
    {
        settings.OperationProcessors.Add(new ODataOperationFilter());
    }
);
```

## Configuration

No configuration required.

## Dependencies

- `Headless.OpenApi.Nswag`

## Side Effects

None.

---

# Headless.OpenApi.Nswag


NSwag OpenAPI document generation with framework-specific processors and defaults.

## Problem Solved

Provides pre-configured NSwag OpenAPI generation with FluentValidation schema enhancement, standard response processors, and framework primitive type mappings for consistent API documentation.

## Key Features

- `FluentValidationSchemaProcessor` - Extracts validation rules into OpenAPI schema
- `NullabilityAsRequiredSchemaProcessor` - Marks non-nullable as required
- Operation processors: Unauthorized, Forbidden, ProblemDetails responses
- Bearer and API key security scheme support
- Framework primitive type mappings (Money, Month, UserId, AccountId)
- API versioning support

## Installation

```bash
dotnet add package Headless.OpenApi.Nswag
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHeadlessNswagOpenApi(options =>
{
    options.AddBearerSecurity = true;
    options.AddPrimitiveMappings = true;
});

var app = builder.Build();

app.MapHeadlessNswagOpenApi();
// or for versioned APIs:
app.MapHeadlessNswagOpenApiVersions();
```

## Configuration

### Options

```csharp
services.AddHeadlessNswagOpenApi(options =>
{
    options.AddBearerSecurity = true;        // JWT Bearer auth
    options.AddApiKeySecurity = true;        // API Key auth
    options.ApiKeyHeaderName = "X-Api-Key";  // Header name
    options.AddPrimitiveMappings = true;     // Framework types
});
```

## Dependencies

- `Headless.Api.Abstractions`
- `NSwag.AspNetCore`
- `FluentValidation`

## Side Effects

- Adds OpenAPI document middleware
- Adds Swagger UI middleware

---

# Headless.OpenApi.Scalar


Scalar API documentation UI integration for OpenAPI.

## Problem Solved

Provides a modern, beautiful API documentation UI using Scalar as an alternative to Swagger UI, with sensible defaults and framework integration.

## Key Features

- Modern, responsive API documentation UI
- Dark mode support with toggle
- Multiple code generation targets (C#, Go, JavaScript, Node, PowerShell, Shell)
- Multiple HTTP clients (HttpClient, Curl, Axios, Fetch, etc.)
- Customizable layout and sorting

## Installation

```bash
dotnet add package Headless.OpenApi.Scalar
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add OpenAPI generation (NSwag or other)
builder.Services.AddHeadlessNswagOpenApi();

var app = builder.Build();

app.MapHeadlessScalarOpenApi();
```

## Configuration

### Options

```csharp
app.MapHeadlessScalarOpenApi(options =>
{
    options.DarkMode = true;
    options.Layout = ScalarLayout.Modern;
}, endpointPrefix: "/docs");
```

## Dependencies

- `Scalar.AspNetCore`

## Side Effects

- Adds Scalar UI middleware at configured endpoint (default: `/scalar`)

---

# Headless.Orm.Couchbase


Couchbase integration with bucket context and cluster management.

## Problem Solved

Provides a structured approach to Couchbase database access with bucket contexts, document sets, and cluster management utilities for .NET applications.

## Key Features

- `CouchbaseBucketContext` - Base context for bucket operations
- Document set extensions for CRUD operations
- Cluster options and transaction configuration providers
- Eventing functions seeder
- Collection management via assembly scanning
- Bucket context initialization

## Installation

```bash
dotnet add package Headless.Orm.Couchbase
```

## Quick Start

```csharp
public class AppBucketContext : CouchbaseBucketContext
{
    public AppBucketContext(IBucket bucket) : base(bucket) { }

    public DocumentSet<Product> Products => GetDocumentSet<Product>("products");
}

// Registration
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddCouchbase(options =>
{
    options.ConnectionString = "couchbase://localhost";
    options.UserName = "admin";
    options.Password = "password";
});
```

## Configuration

### Cluster Options

```csharp
services.AddSingleton<ICouchbaseClusterOptionsProvider, MyClusterOptionsProvider>();
```

## Dependencies

- `CouchbaseNetClient`
- `Headless.BuildingBlocks`

## Side Effects

- Registers bucket context services
- May register eventing functions via seeder

---

# Headless.Orm.EntityFramework


Entity Framework Core integration with framework conventions, global filters, and DDD support.

## Problem Solved

Provides a feature-rich DbContext base class with automatic auditing, soft delete handling, domain event dispatching, multi-tenancy support, and framework type value converters.

## Key Features

- `HeadlessDbContext` - Base DbContext with framework integration
- Automatic `CreatedAt`, `UpdatedAt`, `CreatedBy`, `UpdatedBy` auditing
- Soft delete with `IsDeleted` global filter
- Multi-tenancy with `AccountId` filtering
- Domain event dispatching (local and distributed)
- Value converters: Money, Month, AccountId, UserId, DateTime normalization
- DataGrid extensions for pagination and ordering
- EF migration pre-seeder

## Installation

```bash
dotnet add package Headless.Orm.EntityFramework
```

## Quick Start

```csharp
public class AppDbContext(DbContextOptions<AppDbContext> options) : HeadlessDbContext(options)
{
    public DbSet<Product> Products => Set<Product>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(AppDbContext).Assembly);
    }
}

// Registration
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHeadlessDbContext<AppDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("Default"))
);
```

## Configuration

### Value Converters

```csharp
modelBuilder.Entity<Order>()
    .Property(o => o.Total)
    .HasConversion<MoneyValueConverter>();
```

### Global Filters

Soft delete and multi-tenancy filters are automatically applied.

```csharp
// Disable filters for a query
var allProducts = await dbContext.Products
    .IgnoreQueryFilters()
    .ToListAsync();
```

## Dependencies

- `Headless.Domains`
- `Headless.BuildingBlocks`
- `Microsoft.EntityFrameworkCore`

## Side Effects

- Registers `IHeadlessEntityModelProcessor` as singleton
- Registers default implementations for `IClock`, `IGuidGenerator`, `ICurrentTenant`, `ICurrentUser`
- Replaces `ICompiledQueryCacheKeyGenerator` for multi-tenancy support

---

# Headless.Payments.Paymob.CashIn


Paymob Accept integration for cash-in (payment collection) operations.

## Problem Solved

Provides a comprehensive client for Paymob Accept payment gateway, supporting multiple payment methods (cards, wallets, kiosk, cash collection) with HMAC validation for secure callbacks.

## Key Features

- `IPaymobCashInBroker` - Main payment operations interface
- Payment intentions API (v2)
- Order and transaction management
- Multiple payment methods: Card (iframe), Wallet, Kiosk, Cash Collection
- Saved card token payments
- Refund and void operations
- HMAC callback validation
- Transaction and order queries

## Installation

```bash
dotnet add package Headless.Payments.Paymob.CashIn
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddPaymobCashIn(options =>
{
    options.ApiKey = builder.Configuration["Paymob:ApiKey"];
    options.HmacSecret = builder.Configuration["Paymob:HmacSecret"];
});
```

## Usage

### Create Payment Intention

```csharp
public class PaymentService(IPaymobCashInBroker broker)
{
    public async Task<string> CreatePaymentAsync(decimal amount)
    {
        var response = await broker.CreateIntentionAsync(new CashInCreateIntentionRequest
        {
            Amount = (int)(amount * 100), // Cents
            Currency = "EGP",
            PaymentMethods = [integrationId],
            BillingData = new() { Email = "user@example.com" }
        });

        return response.ClientSecret;
    }
}
```

### Validate Callback

```csharp
[HttpPost("callback")]
public IActionResult HandleCallback([FromBody] CashInCallbackTransaction transaction, [FromQuery] string hmac)
{
    if (!_broker.Validate(transaction, hmac))
        return BadRequest();

    // Process transaction...
    return Ok();
}
```

## Configuration

### appsettings.json

```json
{
  "Paymob": {
    "ApiKey": "your-api-key",
    "HmacSecret": "your-hmac-secret"
  }
}
```

## Dependencies

- `Headless.Base`

## Side Effects

- Registers `IPaymobCashInBroker` as singleton
- Registers `IPaymobCashInAuthenticator` as singleton

---

# Headless.Payments.Paymob.CashOut


Paymob integration for cash-out (disbursement) operations.

## Problem Solved

Provides a client for Paymob disbursement API, enabling payouts to bank accounts, mobile wallets, and Aman cash pickup points.

## Key Features

- `IPaymobCashOutBroker` - Disbursement operations interface
- Bank transfer disbursements
- Wallet disbursements
- Aman cash pickup
- Transaction queries and tracking

## Installation

```bash
dotnet add package Headless.Payments.Paymob.CashOut
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddPaymobCashOut(options =>
{
    options.ApiKey = builder.Configuration["Paymob:CashOut:ApiKey"];
    options.Username = builder.Configuration["Paymob:CashOut:Username"];
    options.Password = builder.Configuration["Paymob:CashOut:Password"];
});
```

## Usage

### Bank Transfer

```csharp
public class DisbursementService(IPaymobCashOutBroker broker)
{
    public async Task<CashOutTransaction> DisburseAsync(decimal amount, string iban)
    {
        return await broker.DisburseAsync(new CashOutDisburseRequest
        {
            Amount = amount,
            Iban = iban,
            TransactionType = BankTransactionTypes.BankCard
        });
    }
}
```

## Configuration

### appsettings.json

```json
{
  "Paymob": {
    "CashOut": {
      "ApiKey": "your-api-key",
      "Username": "your-username",
      "Password": "your-password"
    }
  }
}
```

## Dependencies

- `Headless.Base`

## Side Effects

- Registers `IPaymobCashOutBroker` as singleton
- Registers `IPaymobCashOutAuthenticator` as singleton

---

# Headless.Payments.Paymob.Services


Higher-level services for Paymob payment operations.

## Problem Solved

Provides service-layer abstractions over Paymob cash-in operations with additional models and status tracking for common payment workflows.

## Key Features

- Cash delivery status tracking
- Payment flow orchestration
- Extended status models
- Common payment service patterns

## Installation

```bash
dotnet add package Headless.Payments.Paymob.Services
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add underlying Paymob broker
builder.Services.AddPaymobCashIn(config);

// Add service layer
builder.Services.AddPaymobServices();
```

## Configuration

No additional configuration required beyond `Headless.Payments.Paymob.CashIn`.

## Dependencies

- `Headless.Payments.Paymob.CashIn`

## Side Effects

Registers payment service implementations.

---

# Headless.Permissions.Abstractions


Defines the unified interface for permission management across different providers.

## Problem Solved

Provides a provider-agnostic permission management API, enabling dynamic permission checking with support for multiple grant providers (User, Role, Store) without changing application code.

## Key Features

- `IPermissionManager` - Core interface for permission operations
- `IPermissionDefinitionProvider` - Define permissions in code
- `IPermissionDefinitionManager` - Manage permission definitions
- Grant provider names (User, Role)
- `PermissionDefinition` and `PermissionGroupDefinition` models
- `MultiplePermissionGrantResult` for batch checks

## Installation

```bash
dotnet add package Headless.Permissions.Abstractions
```

## Usage

```csharp
public sealed class OrderService(IPermissionManager permissions, ICurrentUser currentUser)
{
    public async Task DeleteOrderAsync(Guid orderId, CancellationToken ct)
    {
        var result = await permissions.GetAsync("Orders.Delete", currentUser, cancellationToken: ct);

        if (!result.IsGranted)
            throw new ForbiddenException();

        // Delete order...
    }
}
```

### Defining Permissions

```csharp
public class OrderPermissionProvider : IPermissionDefinitionProvider
{
    public void Define(IPermissionDefinitionContext context)
    {
        var group = context.AddGroup("Orders");

        group.AddPermission("Orders.View");
        group.AddPermission("Orders.Create");
        group.AddPermission("Orders.Edit");
        group.AddPermission("Orders.Delete");
    }
}
```

## Configuration

No configuration required. This is an abstractions-only package.

## Dependencies

- `Headless.BuildingBlocks`

## Side Effects

None.

---

# Headless.Permissions.Core


Core implementation of permission management with caching, providers, and authorization.

## Problem Solved

Provides the full permission management implementation including hierarchical grant resolution (User > Role > Store), caching, background initialization, and ASP.NET Core authorization integration.

## Key Features

- `PermissionManager` - Full implementation of `IPermissionManager`
- Grant providers: User, Role, Store
- Static and dynamic permission definition stores
- Permission grant caching with invalidation
- Background service for permission initialization
- ASP.NET Core authorization requirements
- `AlwaysAllowPermissionManager` for testing

## Installation

```bash
dotnet add package Headless.Permissions.Core
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Requires: TimeProvider, ICache, IResourceLock, IGuidGenerator
builder.Services.AddPermissionsManagementCore(options =>
{
    options.CacheKeyPrefix = "permissions:";
});

// Register permission definition providers
builder.Services.AddPermissionDefinitionProvider<OrderPermissionProvider>();

// Add storage (e.g., Entity Framework)
builder.Services.AddPermissionsManagementDbContextStorage<AppDbContext>();
```

### Authorization Requirement

```csharp
[Authorize]
[HasPermission("Orders.Edit")]
public async Task<IActionResult> EditOrder(Guid id) { }
```

## Configuration

### Options

```csharp
services.AddPermissionsManagementCore(options =>
{
    options.CacheKeyPrefix = "permissions:";
});
```

## Dependencies

- `Headless.Permissions.Abstractions`
- `Headless.Domains`
- `Headless.Caching.Abstractions`
- `Headless.ResourceLocks.Abstractions`

## Side Effects

- Registers `IPermissionManager` as transient
- Registers permission stores as singletons
- Starts `PermissionsInitializationBackgroundService` hosted service
- Registers cache invalidation handler

---

# Headless.Permissions.Storage.EntityFramework


Entity Framework Core storage implementation for permission management.

## Problem Solved

Provides persistent storage for permission definitions and grants using Entity Framework Core, enabling database-backed permission management with full CRUD support.

## Key Features

- `IPermissionsDbContext` - DbContext interface for permissions
- `PermissionsDbContext` - Ready-to-use DbContext
- EF repositories for definitions and grants
- Model builder extensions for custom DbContext integration
- Pooled DbContext factory support

## Installation

```bash
dotnet add package Headless.Permissions.Storage.EntityFramework
```

## Quick Start

### Using Built-in DbContext

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddPermissionsManagementDbContextStorage(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("Permissions"))
);
```

### Using Custom DbContext

```csharp
public class AppDbContext : DbContext, IPermissionsDbContext
{
    public DbSet<PermissionDefinitionRecord> PermissionDefinitions => Set<PermissionDefinitionRecord>();
    public DbSet<PermissionGroupDefinitionRecord> PermissionGroupDefinitions => Set<PermissionGroupDefinitionRecord>();
    public DbSet<PermissionGrantRecord> PermissionGrants => Set<PermissionGrantRecord>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ConfigurePermissionManagement();
    }
}

builder.Services.AddPermissionsManagementDbContextStorage<AppDbContext>();
```

## Configuration

No additional configuration required beyond DbContext setup.

## Dependencies

- `Headless.Permissions.Core`
- `Microsoft.EntityFrameworkCore`

## Side Effects

- Registers `IPermissionDefinitionRecordRepository` as singleton
- Registers `IPermissionGrantRepository` as singleton

---

# Headless.PushNotifications.Abstractions


Defines the unified interface for push notification services.

## Problem Solved

Provides a provider-agnostic push notification API, enabling seamless switching between push notification providers (Firebase, development) without changing application code.

## Key Features

- `IPushNotificationService` - Core interface for sending notifications
- `PushNotificationResponse` - Single notification response
- `BatchPushNotificationResponse` - Multicast response with success/failure counts
- Support for custom data payloads

## Installation

```bash
dotnet add package Headless.PushNotifications.Abstractions
```

## Usage

```csharp
public sealed class NotificationService(IPushNotificationService pushService)
{
    public async Task SendAsync(string deviceToken, string title, string message)
    {
        var response = await pushService.SendToDeviceAsync(
            deviceToken,
            title,
            message,
            new Dictionary<string, string> { ["orderId"] = "123" }
        );

        if (!response.IsSuccess)
            _logger.LogError("Push failed: {Error}", response.Error);
    }

    public async Task SendToManyAsync(IReadOnlyList<string> tokens, string title, string message)
    {
        var response = await pushService.SendMulticastAsync(tokens, title, message);
        _logger.LogInformation("Sent: {Success}/{Total}", response.SuccessCount, tokens.Count);
    }
}
```

## Configuration

No configuration required. This is an abstractions-only package.

## Dependencies

None.

## Side Effects

None.

---

# Headless.PushNotifications.Dev


Development push notification implementation that does nothing.

## Problem Solved

Provides a no-op push notification implementation for development/testing environments, preventing actual notifications from being sent during local development.

## Key Features

- `NoopPushNotificationService` - Silent implementation
- No network calls
- Always returns success responses

## Installation

```bash
dotnet add package Headless.PushNotifications.Dev
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

if (builder.Environment.IsDevelopment())
{
    builder.Services.AddNoopPushNotificationService();
}
```

## Configuration

No configuration required.

## Dependencies

- `Headless.PushNotifications.Abstractions`

## Side Effects

- Registers `IPushNotificationService` as singleton

---

# Headless.PushNotifications.Firebase


Firebase Cloud Messaging (FCM) implementation for push notifications.

## Problem Solved

Provides push notification delivery via Firebase Cloud Messaging using the `IPushNotificationService` abstraction for production mobile app notifications.

## Key Features

- `GoogleCloudMessagingPushNotificationService` - FCM implementation
- Single device and multicast support
- Custom data payload support
- Automatic token validation
- Detailed error logging

## Installation

```bash
dotnet add package Headless.PushNotifications.Firebase
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddFirebasePushNotificationService(options =>
{
    options.CredentialsPath = "path/to/service-account.json";
    // Or use environment variable: GOOGLE_APPLICATION_CREDENTIALS
});
```

## Configuration

### Options

```csharp
services.AddFirebasePushNotificationService(options =>
{
    options.CredentialsPath = "firebase-credentials.json";
    options.ProjectId = "your-project-id"; // Optional, read from credentials
});
```

### appsettings.json

```json
{
  "Firebase": {
    "CredentialsPath": "firebase-credentials.json"
  }
}
```

## Dependencies

- `Headless.PushNotifications.Abstractions`
- `FirebaseAdmin`

## Side Effects

- Registers `IPushNotificationService` as singleton
- Initializes Firebase Admin SDK

---



# Headless.Recaptcha


Google reCAPTCHA v2 and v3 integration with verification services and tag helpers.

## Problem Solved

Provides complete Google reCAPTCHA integration including server-side verification for both v2 (checkbox) and v3 (invisible score-based), plus Razor tag helpers for easy frontend integration.

## Key Features

- `IReCaptchaSiteVerifyV2` - reCAPTCHA v2 verification
- `IReCaptchaSiteVerifyV3` - reCAPTCHA v3 verification with score
- Razor tag helpers for script and widget rendering
- Language code provider for localization
- Source-generated JSON serialization

## Installation

```bash
dotnet add package Headless.Recaptcha
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddReCaptchaV3(options =>
{
    options.SiteKey = builder.Configuration["ReCaptcha:SiteKey"];
    options.SiteSecret = builder.Configuration["ReCaptcha:SiteSecret"];
});
```

## Usage

### Server-Side Verification

```csharp
public class LoginController(IReCaptchaSiteVerifyV3 recaptcha)
{
    [HttpPost]
    public async Task<IActionResult> Login(LoginRequest request)
    {
        var result = await recaptcha.VerifyAsync(new ReCaptchaSiteVerifyRequest
        {
            Response = request.RecaptchaToken
        });

        if (!result.Success || result.Score < 0.5f)
            return BadRequest("reCAPTCHA validation failed");

        // Continue with login...
    }
}
```

### Razor Tag Helpers

```html
<!-- reCAPTCHA v3 -->
<recaptcha-v3-script site-key="@config.SiteKey" />
<recaptcha-v3-js action="login" callback="onRecaptchaVerified" />

<!-- reCAPTCHA v2 -->
<recaptcha-v2-script />
<recaptcha-v2-div site-key="@config.SiteKey" />
```

## Configuration

### appsettings.json

```json
{
  "ReCaptcha": {
    "SiteKey": "your-site-key",
    "SiteSecret": "your-secret-key"
  }
}
```

## Dependencies

- `Microsoft.AspNetCore.Razor`

## Side Effects

- Registers `IReCaptchaSiteVerifyV2` and/or `IReCaptchaSiteVerifyV3` as scoped
- Configures HttpClient for reCAPTCHA API

---

# Headless.Redis


Redis utilities and Lua script management for StackExchange.Redis.

## Problem Solved

Provides Redis helper extensions and centralized Lua script loading/execution for StackExchange.Redis, eliminating boilerplate and ensuring consistent script management.

## Key Features

- `ConnectionMultiplexerExtensions` - Helper extensions for Redis connections
- `HeadlessRedisScriptsLoader` - Centralized Lua script management
- `RedisScripts` - Pre-defined script references
- Script caching and execution helpers

## Installation

```bash
dotnet add package Headless.Redis
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

var redis = await ConnectionMultiplexer.ConnectAsync("localhost");
var scriptsLoader = new HeadlessRedisScriptsLoader(redis);

// Load scripts on startup
await scriptsLoader.LoadAsync();
```

## Usage

### Script Execution

```csharp
var db = redis.GetDatabase();
var result = await db.ScriptEvaluateAsync(
    RedisScripts.YourScript,
    keys: [key],
    values: [value]
);
```

## Configuration

No configuration required.

## Dependencies

- `StackExchange.Redis`

## Side Effects

None.

---

# Headless.ResourceLocks.Abstractions


Defines the unified interface for distributed resource locking.

## Problem Solved

Provides a provider-agnostic distributed locking API, enabling coordination across multiple instances with features like lock expiration, renewal, and throttling without changing application code.

## Key Features

- `IResourceLockProvider` - Regular locking with expiration
- `IResourceLock` - Acquired lock handle with release
- `IThrottlingResourceLockProvider` - Rate-limited locking
- `IResourceThrottlingLock` - Throttling lock handle
- Configurable timeouts and expiration

## Installation

```bash
dotnet add package Headless.ResourceLocks.Abstractions
```

## Usage

```csharp
public sealed class OrderService(IResourceLockProvider lockProvider)
{
    public async Task ProcessOrderAsync(Guid orderId, CancellationToken ct)
    {
        var lockResource = $"order:{orderId}";

        await using var @lock = await lockProvider.TryAcquireAsync(
            lockResource,
            timeUntilExpires: TimeSpan.FromMinutes(5),
            acquireTimeout: TimeSpan.FromSeconds(30),
            ct
        );

        if (@lock is null)
            throw new ConcurrencyException("Could not acquire lock");

        // Process order safely...
    }
}
```

## Configuration

No configuration required. This is an abstractions-only package.

## Dependencies

None.

## Side Effects

None.

---

# Headless.ResourceLocks.Cache


Cache-based resource lock storage using ICache.

## Problem Solved

Provides resource lock storage using the framework's `ICache` abstraction, suitable for single-instance deployments or when using a distributed cache like Redis.

## Key Features

- `CacheResourceLockStorage` - Lock storage via `ICache`
- `CacheThrottlingResourceLockStorage` - Throttling lock storage
- Automatic expiration via cache TTL

## Installation

```bash
dotnet add package Headless.ResourceLocks.Cache
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add cache (e.g., Redis cache)
builder.Services.AddRedisCache(options => { /* ... */ });

// Add resource locks with cache storage
builder.Services.AddResourceLock();
builder.Services.AddSingleton<IResourceLockStorage, CacheResourceLockStorage>();
```

## Configuration

No additional configuration required.

## Dependencies

- `Headless.ResourceLocks.Core`
- `Headless.Caching.Abstractions`

## Side Effects

- Registers `IResourceLockStorage` as singleton
- Registers `IThrottlingResourceLockStorage` as singleton (optional)

---

# Headless.ResourceLocks.Core


Core implementation of distributed resource locking with storage abstraction.

## Problem Solved

Provides the lock provider implementation with automatic renewal, expiration handling, and support for pluggable storage backends (cache, Redis).

## Key Features

- `ResourceLockProvider` - Full implementation of `IResourceLockProvider`
- `ThrottlingResourceLockProvider` - Rate-limited lock provider
- `DisposableResourceLock` - Auto-releasing lock handle
- Storage interfaces: `IResourceLockStorage`, `IThrottlingResourceLockStorage`
- Configurable options for timeouts and expiration

## Installation

```bash
dotnet add package Headless.ResourceLocks.Core
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddResourceLock(options =>
{
    options.DefaultTimeUntilExpires = TimeSpan.FromMinutes(20);
    options.DefaultAcquireTimeout = TimeSpan.FromSeconds(30);
});

// Add storage (cache or Redis)
builder.Services.AddResourceLockCacheStorage();
// or
builder.Services.AddResourceLockRedisStorage();
```

## Configuration

### Options

```csharp
services.AddResourceLock(options =>
{
    options.DefaultTimeUntilExpires = TimeSpan.FromMinutes(20);
    options.DefaultAcquireTimeout = TimeSpan.FromSeconds(30);
});
```

## Dependencies

- `Headless.ResourceLocks.Abstractions`

## Side Effects

- Registers `IResourceLockProvider` as singleton
- Registers `IThrottlingResourceLockProvider` as singleton (if throttling storage is provided)

---

# Headless.ResourceLocks.Redis


Redis-based resource lock storage using StackExchange.Redis.

## Problem Solved

Provides high-performance distributed locking using Redis with atomic Lua scripts for lock acquisition and release, suitable for multi-instance production deployments.

## Key Features

- `RedisResourceLockStorage` - Atomic lock operations via Redis
- `RedisThrottlingResourceLockStorage` - Rate-limited locking
- Lua scripts for atomic acquire/release
- High performance and reliability

## Installation

```bash
dotnet add package Headless.ResourceLocks.Redis
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

var redis = await ConnectionMultiplexer.ConnectAsync("localhost");
builder.Services.AddSingleton<IConnectionMultiplexer>(redis);

// Add resource locks with Redis storage
builder.Services.AddResourceLock();
builder.Services.AddSingleton<IResourceLockStorage, RedisResourceLockStorage>();
```

## Configuration

No additional configuration beyond Redis connection.

## Dependencies

- `Headless.ResourceLocks.Core`
- `Headless.Redis`
- `StackExchange.Redis`

## Side Effects

- Registers `IResourceLockStorage` as singleton
- Registers `IThrottlingResourceLockStorage` as singleton (optional)

---

# Headless.Serializer.Abstractions


Defines unified interfaces for serialization and deserialization.

## Problem Solved

Provides provider-agnostic serialization contracts supporting both text (JSON) and binary formats, enabling consistent serialization patterns across the application without coupling to specific implementations.

## Key Features

- `ISerializer` - Base serialization interface with Stream-based operations
- `IBinarySerializer` - Marker interface for binary serializers
- `ITextSerializer` - Marker interface for text-based serializers
- `IJsonSerializer` - Specific interface for JSON serialization
- Extension methods for common serialization patterns

## Installation

```bash
dotnet add package Headless.Serializer.Abstractions
```

## Usage

```csharp
public sealed class DataService(IJsonSerializer serializer)
{
    public T? Load<T>(Stream stream)
    {
        return serializer.Deserialize<T>(stream);
    }

    public void Save<T>(T data, Stream stream)
    {
        serializer.Serialize(data, stream);
    }
}
```

## Configuration

No configuration required. This is an abstractions-only package.

## Dependencies

None.

## Side Effects

None.

---

# Headless.Serializer.Json


System.Text.Json implementation of the serializer abstractions.

## Problem Solved

Provides high-performance JSON serialization using System.Text.Json with customizable options, converters, and type info resolvers for flexible JSON handling.

## Key Features

- `SystemJsonSerializer` - IJsonSerializer implementation
- `IJsonOptionsProvider` - Customizable serialization options
- Built-in converters:
  - `UnixTimeJsonConverter` - Unix timestamp handling
  - `IpAddressJsonConverter` - IP address serialization
  - `EmptyStringAsNullJsonConverter` - Null handling
  - `StringToGuidJsonConverter` - GUID parsing
  - `SingleOrCollectionJsonConverter` - Array/single value handling
- Type info resolvers and modifiers

## Installation

```bash
dotnet add package Headless.Serializer.Json
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Register with default options
builder.Services.AddSingleton<IJsonSerializer, SystemJsonSerializer>();

// Or with custom options provider
builder.Services.AddSingleton<IJsonOptionsProvider, CustomJsonOptionsProvider>();
builder.Services.AddSingleton<IJsonSerializer, SystemJsonSerializer>();
```

## Usage

```csharp
public sealed class ApiClient(IJsonSerializer serializer)
{
    public async Task<T?> GetAsync<T>(HttpClient client, string url)
    {
        await using var stream = await client.GetStreamAsync(url);
        return serializer.Deserialize<T>(stream);
    }
}
```

## Configuration

Implement `IJsonOptionsProvider` for custom options:

```csharp
public sealed class CustomJsonOptionsProvider : IJsonOptionsProvider
{
    public JsonSerializerOptions GetSerializeOptions() => new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        WriteIndented = false
    };

    public JsonSerializerOptions GetDeserializeOptions() => new()
    {
        PropertyNameCaseInsensitive = true
    };
}
```

## Dependencies

- `Headless.Serializer.Abstractions`

## Side Effects

None.

---

# Headless.Serializer.MessagePack


MessagePack binary serialization implementation.

## Problem Solved

Provides compact, high-performance binary serialization using MessagePack format, ideal for caching, messaging, and scenarios requiring smaller payload sizes than JSON.

## Key Features

- `MessagePackSerializer` - IBinarySerializer implementation
- Contractless serialization by default (no attributes required)
- Configurable MessagePackSerializerOptions
- Smaller payloads than JSON
- Faster serialization/deserialization than text formats

## Installation

```bash
dotnet add package Headless.Serializer.MessagePack
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Register with default options (contractless)
builder.Services.AddSingleton<IBinarySerializer, MessagePackSerializer>();
```

## Usage

```csharp
public sealed class CacheService(IBinarySerializer serializer)
{
    public byte[] Serialize<T>(T value)
    {
        using var stream = new MemoryStream();
        serializer.Serialize(value, stream);
        return stream.ToArray();
    }

    public T? Deserialize<T>(byte[] data)
    {
        using var stream = new MemoryStream(data);
        return serializer.Deserialize<T>(stream);
    }
}
```

## Configuration

Custom options can be provided via constructor:

```csharp
var options = MessagePackSerializerOptions.Standard
    .WithResolver(ContractlessStandardResolver.Instance)
    .WithCompression(MessagePackCompression.Lz4BlockArray);

builder.Services.AddSingleton<IBinarySerializer>(
    new MessagePackSerializer(options)
);
```

## Dependencies

- `Headless.Serializer.Abstractions`
- `MessagePack`

## Side Effects

None.

---

# Headless.Settings.Abstractions


Defines interfaces for dynamic application settings management.

## Problem Solved

Provides a provider-agnostic API for managing application settings with support for multiple value providers (default, configuration, global, tenant, user), enabling hierarchical settings that can be overridden at different levels.

## Key Features

- `ISettingManager` - Core interface for reading/writing settings
- `ISettingDefinitionManager` - Setting definition management
- `ISettingDefinitionProvider` - Define settings in code
- `SettingDefinition` - Setting metadata with validation
- Multiple value provider support (default, config, global, tenant, user)
- Extension methods for provider-specific operations

## Installation

```bash
dotnet add package Headless.Settings.Abstractions
```

## Usage

```csharp
public sealed class NotificationService(ISettingManager settingManager)
{
    public async Task<bool> IsEmailEnabledAsync(CancellationToken ct)
    {
        var value = await settingManager.FindAsync(
            "Notifications.EmailEnabled",
            cancellationToken: ct
        );
        return bool.TryParse(value, out var enabled) && enabled;
    }

    public async Task SetUserPreferenceAsync(
        string userId,
        string settingName,
        string value,
        CancellationToken ct)
    {
        await settingManager.SetAsync(
            settingName,
            value,
            SettingValueProviderNames.User,
            userId,
            cancellationToken: ct
        );
    }
}
```

## Configuration

No configuration required. This is an abstractions-only package.

## Dependencies

None.

## Side Effects

None.

---

# Headless.Settings.Core


Core implementation of dynamic settings management with hierarchical value providers.

## Problem Solved

Provides full settings management implementation with multiple value providers (default, configuration, global, tenant, user), caching, encryption for sensitive settings, and automatic initialization via background service.

## Key Features

- `SettingManager` - Full ISettingManager implementation
- `SettingDefinitionManager` - Definition management with static/dynamic stores
- Built-in value providers:
  - `DefaultValueSettingValueProvider` - Default values from definitions
  - `ConfigurationSettingValueProvider` - Values from IConfiguration
  - `GlobalSettingValueProvider` - Application-wide settings
  - `TenantSettingValueProvider` - Tenant-specific settings
  - `UserSettingValueProvider` - User-specific settings
- Setting encryption for sensitive values
- Cache invalidation on changes
- Background initialization service

## Installation

```bash
dotnet add package Headless.Settings.Core
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add required dependencies
builder.Services.AddCaching();
builder.Services.AddResourceLock();

// Add settings management
builder.Services.AddSettingsManagementCore(options =>
{
    options.CacheKeyPrefix = "settings:";
});

// Add storage (EF Core)
builder.Services.AddSettingsManagementDbContextStorage<AppDbContext>();

// Register setting definition providers
builder.Services.AddSettingDefinitionProvider<AppSettingDefinitionProvider>();
```

## Usage

### Define Settings

```csharp
public sealed class AppSettingDefinitionProvider : ISettingDefinitionProvider
{
    public void Define(ISettingDefinitionContext context)
    {
        context.Add(new SettingDefinition(
            name: "App.MaxFileSize",
            displayName: "Maximum File Size",
            defaultValue: "10485760",
            isEncrypted: false
        ));

        context.Add(new SettingDefinition(
            name: "App.ApiKey",
            displayName: "API Key",
            isEncrypted: true
        ));
    }
}
```

### Read/Write Settings

```csharp
public sealed class ConfigService(ISettingManager settings)
{
    public async Task<int> GetMaxFileSizeAsync(CancellationToken ct)
    {
        var value = await settings.FindAsync("App.MaxFileSize", cancellationToken: ct);
        return int.TryParse(value, out var size) ? size : 10485760;
    }

    public async Task SetTenantApiKeyAsync(string tenantId, string apiKey, CancellationToken ct)
    {
        await settings.SetAsync(
            "App.ApiKey",
            apiKey,
            SettingValueProviderNames.Tenant,
            tenantId,
            cancellationToken: ct
        );
    }
}
```

## Configuration

```csharp
services.AddSettingsManagementCore(options =>
{
    options.CacheKeyPrefix = "settings:";
    options.DefinitionCacheDuration = TimeSpan.FromHours(1);
    options.ValueCacheDuration = TimeSpan.FromMinutes(5);
});
```

## Dependencies

- `Headless.Settings.Abstractions`
- `Headless.Caching.Abstractions`
- `Headless.ResourceLocks.Abstractions`
- `Headless.Domains`

## Side Effects

- Registers `ISettingManager` as singleton
- Registers `ISettingDefinitionManager` as singleton
- Registers `SettingsInitializationBackgroundService` as hosted service
- Registers cache invalidation event handler

---

# Headless.Settings.Storage.EntityFramework


Entity Framework Core storage for settings management.

## Problem Solved

Provides EF Core repository implementations for storing setting definitions and values, with support for both dedicated DbContext and shared application DbContext.

## Key Features

- `EfSettingValueRecordRepository` - Setting value storage
- `EfSettingDefinitionRecordRepository` - Definition record storage
- `SettingsDbContext` - Dedicated settings DbContext
- `ISettingsDbContext` - Interface for shared DbContext integration
- Model builder extensions for entity configuration

## Installation

```bash
dotnet add package Headless.Settings.Storage.EntityFramework
```

## Quick Start

### Option 1: Dedicated DbContext

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddSettingsManagementCore();
builder.Services.AddSettingsManagementDbContextStorage(options =>
{
    options.UseNpgsql(connectionString);
});
```

### Option 2: Shared DbContext

```csharp
// In your DbContext
public class AppDbContext : DbContext, ISettingsDbContext
{
    public DbSet<SettingValueRecord> SettingValues => Set<SettingValueRecord>();
    public DbSet<SettingDefinitionRecord> SettingDefinitions => Set<SettingDefinitionRecord>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplySettingsConfiguration();
    }
}

// In Program.cs
builder.Services.AddSettingsManagementCore();
builder.Services.AddSettingsManagementDbContextStorage<AppDbContext>();
```

## Configuration

No additional configuration beyond DbContext setup.

## Dependencies

- `Headless.Settings.Core`
- `Headless.Orm.EntityFramework`
- `Microsoft.EntityFrameworkCore`

## Side Effects

- Registers `ISettingValueRecordRepository` as singleton
- Registers `ISettingDefinitionRecordRepository` as singleton
- Optionally registers pooled `SettingsDbContext` factory

---

# Headless.Sitemaps


XML sitemap generation utilities for SEO.

## Problem Solved

Provides builders and models for generating XML sitemaps and sitemap indexes compliant with the sitemap protocol, supporting localized URLs, images, change frequency, and priority metadata.

## Key Features

- `SitemapUrl` - URL entry with metadata (lastmod, changefreq, priority)
- `SitemapUrls` - Collection builder for sitemap URLs
- `SitemapIndexBuilder` - Sitemap index generation for large sites
- `SitemapAlternateUrl` - Localized/alternate URL support (hreflang)
- `SitemapImage` - Image sitemap support
- `ChangeFrequency` - Standard frequency values (always, hourly, daily, weekly, etc.)

## Installation

```bash
dotnet add package Headless.Sitemaps
```

## Usage

### Basic Sitemap

```csharp
var urls = new SitemapUrls();

urls.Add(new SitemapUrl(
    location: new Uri("https://example.com/"),
    lastModified: DateTime.UtcNow,
    changeFrequency: ChangeFrequency.Daily,
    priority: 1.0f
));

urls.Add(new SitemapUrl(
    location: new Uri("https://example.com/about"),
    changeFrequency: ChangeFrequency.Monthly,
    priority: 0.8f
));

var xml = urls.Build();
```

### Localized URLs

```csharp
var alternates = new[]
{
    new SitemapAlternateUrl("en", new Uri("https://example.com/en/page")),
    new SitemapAlternateUrl("ar", new Uri("https://example.com/ar/page")),
};

urls.Add(new SitemapUrl(
    alternateLocations: alternates,
    lastModified: DateTime.UtcNow
));
```

### Sitemap Index

```csharp
var index = new SitemapIndexBuilder();

index.Add(new SitemapReference(
    new Uri("https://example.com/sitemap-products.xml"),
    DateTime.UtcNow
));

index.Add(new SitemapReference(
    new Uri("https://example.com/sitemap-blog.xml"),
    DateTime.UtcNow
));

var indexXml = index.Build();
```

## Configuration

No configuration required.

## Dependencies

None.

## Side Effects

None.

---

# Headless.Slugs


URL-friendly slug generation from text.

## Problem Solved

Converts arbitrary text into URL-safe slugs with proper Unicode normalization, configurable separators, character replacements, and length limits for SEO-friendly URLs.

## Key Features

- `Slug.Create()` - Static slug generation method
- Unicode normalization (NFC/NFD)
- Configurable separator character
- Character replacement rules
- Maximum length enforcement
- Case transformation options
- Handles non-ASCII characters properly

## Installation

```bash
dotnet add package Headless.Slugs
```

## Usage

### Basic Usage

```csharp
var slug = Slug.Create("Hello World!");
// Result: "hello-world"

var slug2 = Slug.Create(" ");
// Result: "-"
```

### Custom Options

```csharp
var options = new SlugOptions
{
    Separator = "_",
    MaximumLength = 50,
    CasingTransformation = CasingTransformation.LowerCase,
    CanEndWithSeparator = false
};

var slug = Slug.Create("Long Title That Needs Truncation", options);
```

### Character Replacements

```csharp
var options = new SlugOptions
{
    Replacements =
    {
        ["&"] = "and",
        ["@"] = "at",
        ["+"] = "plus"
    }
};

var slug = Slug.Create("Tom & Jerry @ Home", options);
// Result: "tom-and-jerry-at-home"
```

## Configuration

```csharp
var options = new SlugOptions
{
    Separator = "-",              // Default: "-"
    MaximumLength = 100,          // Default: 0 (unlimited)
    CanEndWithSeparator = false,  // Default: false
    CasingTransformation = CasingTransformation.LowerCase
};
```

## Dependencies

None.

## Side Effects

None.

---

# Headless.Sms.Abstractions


Defines the unified interface for SMS sending.

## Problem Solved

Provides a provider-agnostic SMS sending API, enabling consistent SMS functionality across different providers (Twilio, AWS SNS, etc.) without changing application code.

## Key Features

- `ISmsSender` - Core interface for sending SMS
- `SendSingleSmsRequest` - SMS request model
- `SendSingleSmsResponse` - SMS response with status

## Installation

```bash
dotnet add package Headless.Sms.Abstractions
```

## Usage

```csharp
public sealed class OtpService(ISmsSender smsSender)
{
    public async Task SendOtpAsync(string phoneNumber, string code, CancellationToken ct)
    {
        var request = new SendSingleSmsRequest
        {
            To = phoneNumber,
            Message = $"Your verification code is: {code}"
        };

        var response = await smsSender.SendAsync(request, ct);

        if (!response.IsSuccess)
        {
            throw new InvalidOperationException($"SMS failed: {response.ErrorMessage}");
        }
    }
}
```

## Configuration

No configuration required. This is an abstractions-only package.

## Dependencies

None.

## Side Effects

None.

---

# Headless.Sms.Aws


AWS SNS SMS implementation.

## Problem Solved

Provides SMS sending via Amazon Simple Notification Service (SNS), supporting transactional and promotional message types with AWS SDK integration.

## Key Features

- `AwsSnsSmsSender` - ISmsSender implementation using AWS SNS
- Configurable sender ID
- Message type selection (transactional/promotional)
- AWS SDK integration with flexible credentials

## Installation

```bash
dotnet add package Headless.Sms.Aws
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

var awsOptions = builder.Configuration.GetAWSOptions();
builder.Services.AddAwsSnsSmsSender(
    builder.Configuration.GetSection("Sms:Aws"),
    awsOptions
);
```

## Configuration

### appsettings.json

```json
{
  "Sms": {
    "Aws": {
      "SenderId": "MyApp"
    }
  },
  "AWS": {
    "Region": "us-east-1"
  }
}
```

### Code Configuration

```csharp
builder.Services.AddAwsSnsSmsSender(options =>
{
    options.SenderId = "MyApp";
});
```

## Dependencies

- `Headless.Sms.Abstractions`
- `AWSSDK.SimpleNotificationService`
- `AWSSDK.Extensions.NETCore.Setup`

## Side Effects

- Registers `ISmsSender` as singleton
- Registers `IAmazonSimpleNotificationService` if not already registered

---

# Headless.Sms.Cequens


Cequens SMS gateway implementation.

## Problem Solved

Provides SMS sending via Cequens API, a regional SMS provider popular in the Middle East and North Africa with token-based authentication.

## Key Features

- `CequensSmsSender` - ISmsSender implementation using Cequens
- JWT token-based authentication with auto-refresh
- Configurable sender name
- Batch SMS support

## Installation

```bash
dotnet add package Headless.Sms.Cequens
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddCequensSmsSender(options =>
{
    options.ApiKey = "your-api-key";
    options.UserName = "your-username";
    options.SenderName = "MyApp";
});
```

## Configuration

### appsettings.json

```json
{
  "Sms": {
    "Cequens": {
      "ApiKey": "your-api-key",
      "UserName": "your-username",
      "SenderName": "MyApp"
    }
  }
}
```

## Dependencies

- `Headless.Sms.Abstractions`

## Side Effects

- Registers `ISmsSender` as singleton
- Registers `HttpClient` for Cequens API

---

# Headless.Sms.Connekio


Connekio SMS gateway implementation.

## Problem Solved

Provides SMS sending via Connekio API, supporting both single and batch SMS delivery with basic authentication.

## Key Features

- `ConnekioSmsSender` - ISmsSender implementation using Connekio
- Basic authentication (username:password:accountId)
- Single and batch SMS support
- Configurable sender name

## Installation

```bash
dotnet add package Headless.Sms.Connekio
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddConnekioSmsSender(options =>
{
    options.UserName = "your-username";
    options.Password = "your-password";
    options.AccountId = "your-account-id";
    options.Sender = "MyApp";
});
```

## Configuration

### appsettings.json

```json
{
  "Sms": {
    "Connekio": {
      "UserName": "your-username",
      "Password": "your-password",
      "AccountId": "your-account-id",
      "Sender": "MyApp"
    }
  }
}
```

## Dependencies

- `Headless.Sms.Abstractions`

## Side Effects

- Registers `ISmsSender` as singleton
- Registers `HttpClient` for Connekio API

---

# Headless.Sms.Dev


Development SMS implementations for testing.

## Problem Solved

Provides development-only SMS senders that either log messages to a file or silently discard them, enabling SMS workflow testing without sending actual messages.

## Key Features

- `DevSmsSender` - Writes SMS to a file for inspection
- `NoopSmsSender` - Silently discards all messages
- No external dependencies or API calls

## Installation

```bash
dotnet add package Headless.Sms.Dev
```

## Quick Start

### File-based Logging

```csharp
var builder = WebApplication.CreateBuilder(args);

if (builder.Environment.IsDevelopment())
{
    builder.Services.AddDevSmsSender("sms-log.txt");
}
```

### No-op (Silent)

```csharp
var builder = WebApplication.CreateBuilder(args);

if (builder.Environment.IsDevelopment())
{
    builder.Services.AddNoopSmsSender();
}
```

## Configuration

No configuration required.

## Dependencies

- `Headless.Sms.Abstractions`

## Side Effects

- Registers `ISmsSender` as singleton
- `DevSmsSender` writes to the specified file path

---

# Headless.Sms.Infobip


Infobip SMS gateway implementation.

## Problem Solved

Provides SMS sending via Infobip's global messaging platform with comprehensive delivery reporting.

## Key Features

- `InfobipSmsSender` - ISmsSender implementation using Infobip
- API key authentication
- Configurable base URL for regional endpoints
- Comprehensive delivery status reporting

## Installation

```bash
dotnet add package Headless.Sms.Infobip
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddInfobipSmsSender(options =>
{
    options.ApiKey = "your-api-key";
    options.BaseUrl = "https://api.infobip.com";
    options.SenderName = "MyApp";
});
```

## Configuration

### appsettings.json

```json
{
  "Sms": {
    "Infobip": {
      "ApiKey": "your-api-key",
      "BaseUrl": "https://api.infobip.com",
      "SenderName": "MyApp"
    }
  }
}
```

## Dependencies

- `Headless.Sms.Abstractions`

## Side Effects

- Registers `ISmsSender` as singleton

---

# Headless.Sms.Twilio


Twilio SMS implementation.

## Problem Solved

Provides SMS sending via Twilio's messaging API with support for sender numbers and messaging service SIDs.

## Key Features

- `TwilioSmsSender` - ISmsSender implementation using Twilio
- Account SID and Auth Token authentication
- Configurable sender phone number
- Messaging Service SID support

## Installation

```bash
dotnet add package Headless.Sms.Twilio
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddTwilioSmsSender(options =>
{
    options.AccountSid = "your-account-sid";
    options.AuthToken = "your-auth-token";
    options.From = "+1234567890";
});
```

## Configuration

### appsettings.json

```json
{
  "Sms": {
    "Twilio": {
      "AccountSid": "your-account-sid",
      "AuthToken": "your-auth-token",
      "From": "+1234567890"
    }
  }
}
```

### Code Configuration

```csharp
builder.Services.AddTwilioSmsSender(options =>
{
    options.AccountSid = config["Twilio:AccountSid"]!;
    options.AuthToken = config["Twilio:AuthToken"]!;
    options.From = config["Twilio:From"]!;
    // Or use MessagingServiceSid instead of From
    options.MessagingServiceSid = config["Twilio:MessagingServiceSid"];
});
```

## Dependencies

- `Headless.Sms.Abstractions`
- `Twilio`

## Side Effects

- Registers `ISmsSender` as singleton

---

# Headless.Sms.VictoryLink


VictoryLink SMS gateway implementation.

## Problem Solved

Provides SMS sending via VictoryLink API, a regional SMS provider serving the Middle East market.

## Key Features

- `VictoryLinkSmsSender` - ISmsSender implementation using VictoryLink
- Username/password authentication
- Configurable sender name
- Response code handling

## Installation

```bash
dotnet add package Headless.Sms.VictoryLink
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddVictoryLinkSmsSender(options =>
{
    options.Username = "your-username";
    options.Password = "your-password";
    options.SenderName = "MyApp";
});
```

## Configuration

### appsettings.json

```json
{
  "Sms": {
    "VictoryLink": {
      "Username": "your-username",
      "Password": "your-password",
      "SenderName": "MyApp"
    }
  }
}
```

## Dependencies

- `Headless.Sms.Abstractions`

## Side Effects

- Registers `ISmsSender` as singleton

---

# Headless.Sms.Vodafone


Vodafone SMS gateway implementation.

## Problem Solved

Provides SMS sending via Vodafone's enterprise messaging API with OAuth2 authentication.

## Key Features

- `VodafoneSmsSender` - ISmsSender implementation using Vodafone
- OAuth2 client credentials authentication
- Configurable sender name and base URL
- Regional endpoint support

## Installation

```bash
dotnet add package Headless.Sms.Vodafone
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddVodafoneSmsSender(options =>
{
    options.ClientId = "your-client-id";
    options.ClientSecret = "your-client-secret";
    options.SenderName = "MyApp";
    options.BaseUrl = "https://api.vodafone.com";
});
```

## Configuration

### appsettings.json

```json
{
  "Sms": {
    "Vodafone": {
      "ClientId": "your-client-id",
      "ClientSecret": "your-client-secret",
      "SenderName": "MyApp",
      "BaseUrl": "https://api.vodafone.com"
    }
  }
}
```

## Dependencies

- `Headless.Sms.Abstractions`

## Side Effects

- Registers `ISmsSender` as singleton

---

# Headless.Sql.Abstractions


Defines interfaces for SQL database connection management.

## Problem Solved

Provides provider-agnostic interfaces for SQL connection creation and validation, enabling consistent database access patterns across different SQL providers (PostgreSQL, SQL Server, SQLite).

## Key Features

- `ISqlConnectionFactory` - Create and manage database connections
- `ISqlCurrentConnection` - Access current ambient connection
- `IConnectionStringChecker` - Validate connection strings and database existence

## Installation

```bash
dotnet add package Headless.Sql.Abstractions
```

## Usage

```csharp
public sealed class OrderRepository(ISqlConnectionFactory connectionFactory)
{
    public async Task<Order?> GetByIdAsync(Guid id, CancellationToken ct)
    {
        await using var connection = await connectionFactory.CreateNewConnectionAsync(ct);

        return await connection.QuerySingleOrDefaultAsync<Order>(
            "SELECT * FROM orders WHERE id = @Id",
            new { Id = id }
        );
    }
}
```

## Configuration

No configuration required. This is an abstractions-only package.

## Dependencies

None.

## Side Effects

None.

---

# Headless.Sql.PostgreSql


PostgreSQL connection factory using Npgsql.

## Problem Solved

Provides PostgreSQL-specific implementation of the SQL connection factory, enabling efficient connection management with Npgsql.

## Key Features

- `NpgsqlConnectionFactory` - ISqlConnectionFactory implementation
- `NpgsqlConnectionStringChecker` - Connection string validation
- Returns strongly-typed `NpgsqlConnection` instances

## Installation

```bash
dotnet add package Headless.Sql.PostgreSql
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

var connectionString = builder.Configuration.GetConnectionString("Default")!;
builder.Services.AddSingleton<ISqlConnectionFactory>(
    new NpgsqlConnectionFactory(connectionString)
);
```

## Usage

```csharp
public sealed class ReportService(ISqlConnectionFactory connectionFactory)
{
    public async Task<IEnumerable<Report>> GetReportsAsync(CancellationToken ct)
    {
        await using var connection = await connectionFactory.CreateNewConnectionAsync(ct);

        return await connection.QueryAsync<Report>(
            "SELECT * FROM reports WHERE created_at > @Date",
            new { Date = DateTime.UtcNow.AddDays(-30) }
        );
    }
}
```

## Configuration

Connection string via constructor:

```csharp
services.AddSingleton<ISqlConnectionFactory>(sp =>
{
    var config = sp.GetRequiredService<IConfiguration>();
    return new NpgsqlConnectionFactory(config.GetConnectionString("Postgres")!);
});
```

## Dependencies

- `Headless.Sql.Abstractions`
- `Npgsql`

## Side Effects

None (manual registration required).

---

# Headless.Sql.Sqlite


SQLite connection factory using Microsoft.Data.Sqlite.

## Problem Solved

Provides SQLite-specific implementation of the SQL connection factory, ideal for development, testing, and embedded database scenarios.

## Key Features

- `SqliteConnectionFactory` - ISqlConnectionFactory implementation
- `SqliteConnectionStringChecker` - Connection string validation
- Returns strongly-typed `SqliteConnection` instances
- Lightweight, file-based database support

## Installation

```bash
dotnet add package Headless.Sql.Sqlite
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

var connectionString = "Data Source=app.db";
builder.Services.AddSingleton<ISqlConnectionFactory>(
    new SqliteConnectionFactory(connectionString)
);
```

## Usage

```csharp
public sealed class CacheRepository(ISqlConnectionFactory connectionFactory)
{
    public async Task<string?> GetAsync(string key, CancellationToken ct)
    {
        await using var connection = await connectionFactory.CreateNewConnectionAsync(ct);

        return await connection.QuerySingleOrDefaultAsync<string>(
            "SELECT value FROM cache WHERE key = @Key",
            new { Key = key }
        );
    }
}
```

## Configuration

```csharp
// In-memory database (for testing)
services.AddSingleton<ISqlConnectionFactory>(
    new SqliteConnectionFactory("Data Source=:memory:")
);

// File-based database
services.AddSingleton<ISqlConnectionFactory>(
    new SqliteConnectionFactory("Data Source=app.db")
);
```

## Dependencies

- `Headless.Sql.Abstractions`
- `Microsoft.Data.Sqlite`

## Side Effects

None (manual registration required).

---

# Headless.Sql.SqlServer


SQL Server connection factory using Microsoft.Data.SqlClient.

## Problem Solved

Provides SQL Server-specific implementation of the SQL connection factory, enabling efficient connection management with Microsoft.Data.SqlClient.

## Key Features

- `SqlServerConnectionFactory` - ISqlConnectionFactory implementation
- `SqlServerConnectionStringChecker` - Connection string validation
- Returns strongly-typed `SqlConnection` instances

## Installation

```bash
dotnet add package Headless.Sql.SqlServer
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

var connectionString = builder.Configuration.GetConnectionString("Default")!;
builder.Services.AddSingleton<ISqlConnectionFactory>(
    new SqlServerConnectionFactory(connectionString)
);
```

## Usage

```csharp
public sealed class ReportService(ISqlConnectionFactory connectionFactory)
{
    public async Task<IEnumerable<Report>> GetReportsAsync(CancellationToken ct)
    {
        await using var connection = await connectionFactory.CreateNewConnectionAsync(ct);

        return await connection.QueryAsync<Report>(
            "SELECT * FROM Reports WHERE CreatedAt > @Date",
            new { Date = DateTime.UtcNow.AddDays(-30) }
        );
    }
}
```

## Configuration

Connection string via constructor:

```csharp
services.AddSingleton<ISqlConnectionFactory>(sp =>
{
    var config = sp.GetRequiredService<IConfiguration>();
    return new SqlServerConnectionFactory(config.GetConnectionString("SqlServer")!);
});
```

## Dependencies

- `Headless.Sql.Abstractions`
- `Microsoft.Data.SqlClient`

## Side Effects

None (manual registration required).

---

# Headless.Testing.Testcontainers


Testcontainers fixtures for integration testing.

## Problem Solved

Provides pre-configured Testcontainers fixtures for common infrastructure (Redis, databases) enabling reliable integration tests with real dependencies running in Docker.

## Key Features

- `HeadlessRedisFixture` - Redis 7 Alpine container fixture
- `TestContextMessageSink` - xUnit output integration
- Automatic container lifecycle management
- Clean test isolation

## Installation

```bash
dotnet add package Headless.Testing.Testcontainers
```

## Quick Start

```csharp
public sealed class CacheIntegrationTests : IClassFixture<HeadlessRedisFixture>
{
    private readonly HeadlessRedisFixture _redis;

    public CacheIntegrationTests(HeadlessRedisFixture redis)
    {
        _redis = redis;
    }

    [Fact]
    public async Task should_cache_value()
    {
        var multiplexer = await ConnectionMultiplexer.ConnectAsync(
            _redis.Container.GetConnectionString()
        );
        var db = multiplexer.GetDatabase();

        await db.StringSetAsync("key", "value");
        var result = await db.StringGetAsync("key");

        result.ToString().Should().Be("value");
    }
}
```

## Prerequisites

- Docker must be running

## Configuration

No configuration required. Containers use sensible defaults.

## Dependencies

- `Headless.Testing`
- `Testcontainers`
- `Testcontainers.Redis`
- `Testcontainers.Xunit`

## Side Effects

- Starts Docker containers during test execution
- Containers are automatically stopped after tests complete

---

# Headless.Testing


Core testing utilities and base classes for xUnit tests.

## Problem Solved

Provides reusable test infrastructure including base classes, retry attributes, test ordering, fake helpers, and assertion extensions for consistent, reliable testing across the framework.

## Key Features

- `TestBase` - Abstract base class with lifecycle, logging, and Faker
- `RetryFactAttribute` / `RetryTheoryAttribute` - Automatic test retry on failure
- `AlfaTestsOrderer` - Alphabetical test ordering
- `TestHelpers` - Logging factory and utility methods
- `TestCurrentUser` / `TestCurrentTenant` - Fake context implementations
- `TestClock` - Controllable time provider for tests
- Assertion extensions for async operations

## Installation

```bash
dotnet add package Headless.Testing
```

## Quick Start

```csharp
public sealed class OrderServiceTests : TestBase
{
    private readonly OrderService _sut;

    public OrderServiceTests()
    {
        _sut = new OrderService(Logger);
    }

    [Fact]
    public async Task should_create_order()
    {
        // Arrange
        var order = Faker.OrderFaker().Generate();

        // Act
        var result = await _sut.CreateAsync(order, AbortToken);

        // Assert
        result.Should().NotBeNull();
    }

    [RetryFact(MaxRetries = 3)]
    public async Task should_handle_flaky_operation()
    {
        // Test with automatic retry on failure
    }
}
```

## Usage

### Test Lifecycle

```csharp
public sealed class MyTests : TestBase
{
    public override async ValueTask InitializeAsync()
    {
        // Called before each test
        await base.InitializeAsync();
    }

    protected override async ValueTask DisposeAsyncCore()
    {
        // Called after each test
        await base.DisposeAsyncCore();
    }
}
```

### Controllable Time

```csharp
var clock = new TestClock(new DateTime(2024, 1, 1));
var service = new ExpirationService(clock);

clock.Advance(TimeSpan.FromDays(30));
var isExpired = service.IsExpired(); // true
```

## Configuration

No configuration required.

## Dependencies

- `xunit.v3`
- `Bogus`
- `Microsoft.Extensions.Logging`

## Side Effects

None.

---

# Headless.Tus.Azure


Azure Blob Storage TUS store implementation.

## Problem Solved

Provides a full-featured TUS protocol store using Azure Blob Storage for resumable file uploads, supporting creation, concatenation, expiration, checksum verification, and termination extensions.

## Key Features

- `TusAzureStore` - Complete ITusStore implementation
- Supports TUS extensions:
  - Creation / CreationDeferLength
  - Concatenation
  - Expiration
  - Checksum
  - Termination
- Azure Blob file locking
- Configurable blob prefix and container
- Automatic container creation

## Installation

```bash
dotnet add package Headless.Tus.Azure
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

var blobServiceClient = new BlobServiceClient(connectionString);

var store = new TusAzureStore(
    blobServiceClient,
    new TusAzureStoreOptions
    {
        ContainerName = "uploads",
        BlobPrefix = "tus/",
        CreateContainerIfNotExists = true
    }
);

var app = builder.Build();

app.MapTus("/files", async _ => new DefaultTusConfiguration
{
    Store = store,
    UrlPath = "/files"
});
```

## Configuration

```csharp
var options = new TusAzureStoreOptions
{
    ContainerName = "uploads",
    BlobPrefix = "tus/",
    CreateContainerIfNotExists = true,
    ContainerPublicAccessType = PublicAccessType.None
};
```

## Dependencies

- `Headless.Tus`
- `Azure.Storage.Blobs`
- `tusdotnet`

## Side Effects

- Creates Azure Blob container if configured

---

# Headless.Tus.ResourceLock


TUS file locking using Headless.ResourceLocks.

## Problem Solved

Provides a TUS file lock provider implementation using the framework's distributed resource locking, enabling concurrent upload coordination across multiple instances.

## Key Features

- `ResourceLockTusLockProvider` - ITusFileLockProvider implementation
- `ResourceLockTusLock` - Distributed file lock wrapper
- Works with any IResourceLockProvider (Redis, Cache)

## Installation

```bash
dotnet add package Headless.Tus.ResourceLock
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add resource lock provider first
builder.Services.AddResourceLock();
builder.Services.AddResourceLockRedisStorage();

// Add TUS lock provider
builder.Services.AddResourceLockTusLockProvider();

var app = builder.Build();

app.MapTus("/files", async ctx =>
{
    var lockProvider = ctx.RequestServices.GetRequiredService<ITusFileLockProvider>();

    return new DefaultTusConfiguration
    {
        Store = store,
        UrlPath = "/files",
        FileLockProvider = lockProvider
    };
});
```

## Configuration

No additional configuration required beyond resource lock setup.

## Dependencies

- `Headless.Tus`
- `Headless.ResourceLocks.Abstractions`
- `tusdotnet`

## Side Effects

- Registers `ITusFileLockProvider` as singleton

---

# Headless.Tus


Core TUS protocol utilities and extensions.

## Problem Solved

Provides shared utilities and base functionality for TUS (resumable file upload) protocol implementations, building on the tusdotnet library.

## Key Features

- Shared TUS protocol utilities
- Base types for TUS stores
- File metadata handling
- Extension method helpers

## Installation

```bash
dotnet add package Headless.Tus
```

## Usage

This is a base package typically used by specific TUS store implementations (Azure, local filesystem). See `Headless.Tus.Azure` for a complete implementation.

## Configuration

No configuration required.

## Dependencies

- `tusdotnet`

## Side Effects

None.

---

# Headless.Caching.Memory

> **Note:** This package is currently a placeholder and contains no implementation.

## Status

This package directory exists for future development. Functionality may be available through:
- `Headless.Caching.Memory` - In-memory caching implementation

## Installation

Not available for installation.

---

# Headless.Cap.Dashboard

> **Note:** This package is currently a placeholder and contains no implementation.

## Status

This package directory exists for future development. Dashboard functionality is available through:
- `Headless.Messages.Dashboard` - Web dashboard for messaging system

## Installation

Not available for installation.

---

# Headless.Domain

Core domain-driven design abstractions including entities, aggregate roots, value objects, auditing, and messaging interfaces.

## Problem Solved

Provides building blocks for implementing DDD patterns: entities with identity, aggregate roots with domain events, value objects, auditing interfaces, and messaging contracts.

## Key Features

- **Entity Abstractions**: `IEntity`, `IEntity<T>`, base `Entity` class
- **Aggregate Roots**: `IAggregateRoot`, `AggregateRoot` with built-in message emission
- **Value Objects**: `ValueObject` base class with equality
- **Auditing**: `ICreateAudit`, `IUpdateAudit`, `IDeleteAudit`, `ISuspendAudit`
- **Concurrency**: `IHasConcurrencyStamp`, `IHasETag`
- **Multi-tenancy**: `IMultiTenant`
- **Local Messaging**: `ILocalMessage`, `ILocalMessagePublisher`, `ILocalMessageHandler`
- **Distributed Messaging**: `IDistributedMessage`, `IDistributedMessagePublisher`, `IDistributedMessageHandler`
- **Entity Events**: `EntityCreatedEventData`, `EntityUpdatedEventData`, `EntityDeletedEventData`

## Installation

```bash
dotnet add package Headless.Domains
```

## Quick Start

```csharp
public sealed class Order : AggregateRoot<Guid>, ICreateAudit
{
    public required string CustomerName { get; init; }
    public decimal Total { get; private set; }
    public DateTimeOffset CreatedAt { get; set; }
    public string? CreatedBy { get; set; }

    public void Complete()
    {
        Status = OrderStatus.Completed;
        AddMessage(new OrderCompletedEvent(Id));
    }
}

public sealed record OrderCompletedEvent(Guid OrderId) : ILocalMessage;
```

### Auditing

Implement audit interfaces for automatic tracking:

```csharp
public sealed class Product : Entity<int>, ICreateAudit, IUpdateAudit
{
    public required string Name { get; set; }
    public DateTimeOffset CreatedAt { get; set; }
    public string? CreatedBy { get; set; }
    public DateTimeOffset? UpdatedAt { get; set; }
    public string? UpdatedBy { get; set; }
}
```

### Value Objects

```csharp
public sealed class Address : ValueObject
{
    public required string Street { get; init; }
    public required string City { get; init; }

    protected override IEnumerable<object?> GetEqualityComponents()
    {
        yield return Street;
        yield return City;
    }
}
```

## Configuration

No configuration required. This is an abstractions package.

## Dependencies

None.

## Side Effects

None.

---

# Headless.Domain.DistributedMessagePublisher.Cap

CAP-based implementation of `IDistributedMessagePublisher` for reliable distributed messaging with transactional outbox pattern.

## Problem Solved

Provides reliable distributed message publishing using CAP (eventually consistent processing) with support for multiple message brokers (RabbitMQ, Kafka, etc.) and transactional outbox.

## Key Features

- `IDistributedMessagePublisher` implementation using DotNetCore.CAP
- Transactional outbox pattern support
- Multiple broker support (RabbitMQ, Kafka, Azure Service Bus, etc.)
- Dashboard for monitoring
- Automatic retry and dead-letter handling
- JSON serialization integration

## Installation

```bash
dotnet add package Headless.Domains.DistributedMessagePublisher.Cap
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddCap(options =>
{
    options.UseEntityFramework<AppDbContext>();
    options.UseRabbitMQ("localhost");
    options.UseDashboard();
});

builder.Services.AddCapDistributedMessagePublisher();
```

### Publishing Messages

```csharp
public sealed class OrderService(IDistributedMessagePublisher publisher)
{
    public async Task CompleteOrderAsync(Order order, CancellationToken ct)
    {
        order.Complete();

        // Publish distributed message
        await publisher.PublishAsync(
            new OrderCompletedMessage(order.Id, order.Total),
            ct
        ).AnyContext();
    }
}
```

### Handling Messages

```csharp
[Message("orders.completed")]
public sealed class OrderCompletedHandler : IDistributedMessageHandler<OrderCompletedMessage>
{
    public async Task HandleAsync(OrderCompletedMessage message, CancellationToken ct)
    {
        // Handle the message
    }
}
```

## Configuration

Configured via CAP options. See CAP documentation for broker-specific settings.

## Dependencies

- `Headless.Domains`
- `Headless.Base`
- `Headless.Serializer.Json`
- `DotNetCore.CAP`
- `DotNetCore.CAP.Dashboard`

## Side Effects

- Registers `IDistributedMessagePublisher`
- CAP registers background services for message processing

---

# Headless.Domain.LocalMessagePublisher.DI

DI-based implementation of `ILocalMessagePublisher` for in-process domain event handling.

## Problem Solved

Provides in-memory local message publishing that resolves handlers from the DI container, enabling decoupled event-driven architecture within a single process.

## Key Features

- `ILocalMessagePublisher` implementation using DI
- Automatic handler discovery and resolution
- Handler ordering via `LocalEventHandlerOrderAttribute`
- Sync and async publishing support
- Scoped handler resolution

## Installation

```bash
dotnet add package Headless.Domains.LocalMessagePublisher.DI
```

## Quick Start

```csharp
var builder = WebApplication.CreateBuilder(args);

// Register local message publisher
builder.Services.AddLocalMessagePublisher();

// Register handlers (automatically discovered or explicit)
builder.Services.AddScoped<ILocalMessageHandler<OrderCreatedEvent>, OrderCreatedHandler>();
```

### Publishing Events

```csharp
public sealed class OrderService(ILocalMessagePublisher publisher)
{
    public async Task CreateOrderAsync(Order order, CancellationToken ct)
    {
        await _repository.AddAsync(order, ct).AnyContext();

        await publisher.PublishAsync(new OrderCreatedEvent(order.Id), ct).AnyContext();
    }
}
```

### Handling Events

```csharp
public sealed class OrderCreatedHandler : ILocalMessageHandler<OrderCreatedEvent>
{
    public async Task HandleAsync(OrderCreatedEvent message, CancellationToken ct)
    {
        // Send email, update read model, etc.
    }
}

[LocalEventHandlerOrder(1)] // Execute first
public sealed class AuditHandler : ILocalMessageHandler<OrderCreatedEvent>
{
    public Task HandleAsync(OrderCreatedEvent message, CancellationToken ct)
    {
        // Audit logging
        return Task.CompletedTask;
    }
}
```

## Configuration

No configuration required.

## Dependencies

- `Headless.Domains`
- `Headless.Hosting`

## Side Effects

- Registers `ILocalMessagePublisher` as scoped

---

# Headless.Messages.Abstractions

Core abstractions for type-safe, high-performance message consumption and publishing with outbox pattern support.

## Problem Solved

Provides standardized interfaces for building reliable distributed messaging systems with compile-time type safety, avoiding reflection overhead and enabling transactional outbox patterns for guaranteed message delivery.

## Key Features

- **Type-Safe Consumption**: `IConsume<TMessage>` interface with `ConsumeContext<TMessage>` for compile-time verification (5-8x faster than reflection)
- **Outbox Publishing**: `IOutboxPublisher` for transactional message publishing with database consistency
- **Rich Metadata**: Message ID, correlation ID, timestamps, headers, and topic routing
- **Consumer Configuration**: `IMessagingBuilder` for assembly scanning and manual consumer registration
- **Delayed Publishing**: Schedule messages for future delivery
- **Multi-Type Consumers**: Single consumer can handle multiple message types

## Installation

```bash
dotnet add package Headless.Messages.Abstractions
```

## Quick Start

```csharp
// Define message consumer
public sealed class OrderPlacedHandler(
    IOrderRepository orders,
    ILogger<OrderPlacedHandler> logger) : IConsume<OrderPlacedEvent>
{
    public async ValueTask Consume(
        ConsumeContext<OrderPlacedEvent> context,
        CancellationToken cancellationToken)
    {
        logger.LogInformation(
            "Processing order {OrderId} at {Timestamp}",
            context.Message.OrderId,
            context.Timestamp);

        await orders.CreateAsync(context.Message, cancellationToken);
    }
}

// Register consumers
builder.Services.AddMessages(options =>
{
    options.ScanConsumers(typeof(Program).Assembly);
    options.WithTopicMapping<OrderPlacedEvent>("orders.placed");
});

// Publish with outbox
public sealed class OrderService(IOutboxPublisher publisher)
{
    public async Task PlaceOrderAsync(Order order, CancellationToken ct)
    {
        // Publish transactionally with database changes
        await publisher.PublishAsync("orders.placed", new OrderPlacedEvent
        {
            OrderId = order.Id,
            Total = order.Total
        }, cancellationToken: ct);
    }
}
```

## Configuration

No configuration required. This is an abstractions package. Implementations are provided by:
- `Headless.Messages.Core` (base implementation)
- Transport packages: `Headless.Messages.RabbitMQ`, `Headless.Messages.Kafka`, etc.
- Storage packages: `Headless.Messages.PostgreSql`, `Headless.Messages.SqlServer`, etc.

## Dependencies

- `Headless.Base`
- `Headless.Checks`
- `Microsoft.Extensions.DependencyInjection.Abstractions`
- `Microsoft.Extensions.Logging.Abstractions`

## Side Effects

None. This is an abstractions package.

---

# Headless.Messages.AmazonSQS

Amazon SQS and SNS transport provider for the messaging system.

## Problem Solved

Enables reliable message delivery using AWS SQS queues and SNS topics with automatic queue creation, dead-letter queues, and IAM policy management.

## Key Features

- **SQS Consumer**: Reliable queue-based message consumption
- **SNS Publisher**: Topic-based message distribution
- **Auto-Provisioning**: Automatic queue and topic creation
- **Dead Letter Queues**: Built-in failure handling
- **IAM Integration**: Automatic policy configuration

## Installation

```bash
dotnet add package Headless.Messages.AmazonSQS
```

## Quick Start

```csharp
builder.Services.AddMessages(options =>
{
    options.UsePostgreSql("connection_string");

    options.UseAmazonSQS(sqs =>
    {
        sqs.Region = "us-east-1";
        sqs.Credentials = new BasicAWSCredentials("key", "secret");
    });

    options.ScanConsumers(typeof(Program).Assembly);
});
```

## Configuration

```csharp
options.UseAmazonSQS(sqs =>
{
    sqs.Region = "us-east-1";
    sqs.Credentials = awsCredentials;
    sqs.SNSServiceUrl = "https://sns.us-east-1.amazonaws.com";
    sqs.SQSServiceUrl = "https://sqs.us-east-1.amazonaws.com";
});
```

## Dependencies

- `Headless.Messages.Core`
- `AWSSDK.SimpleNotificationService`
- `AWSSDK.SQS`

## Side Effects

- Creates SQS queues and SNS topics if they don't exist
- Configures IAM policies for queue access
- Establishes persistent connections to AWS services

---

# Headless.Messages.AzureServiceBus

Azure Service Bus transport provider for the messaging system.

## Problem Solved

Enables enterprise messaging using Azure Service Bus with topics, subscriptions, sessions, and advanced routing capabilities.

## Key Features

- **Topic/Subscription Model**: Pub/sub messaging with filters
- **Sessions**: Message ordering and state management
- **Auto-Provisioning**: Automatic topic and subscription creation
- **Advanced Routing**: Message routing rules and filters
- **Enterprise Features**: Transactions, duplicate detection, dead-lettering

## Installation

```bash
dotnet add package Headless.Messages.AzureServiceBus
```

## Quick Start

```csharp
builder.Services.AddMessages(options =>
{
    options.UseSqlServer("connection_string");

    options.UseAzureServiceBus(asb =>
    {
        asb.ConnectionString = "Endpoint=sb://namespace.servicebus.windows.net/;...";
        asb.TopicPath = "myapp";
    });

    options.ScanConsumers(typeof(Program).Assembly);
});
```

## Configuration

```csharp
options.UseAzureServiceBus(asb =>
{
    asb.ConnectionString = "connection_string";
    asb.TopicPath = "myapp-topic";
    asb.EnableSessions = true;
    asb.ManagementTokenProvider = tokenProvider;
});
```

## Dependencies

- `Headless.Messages.Core`
- `Azure.Messaging.ServiceBus`

## Side Effects

- Creates Service Bus topics and subscriptions if they don't exist
- Establishes persistent connections to Azure Service Bus
- Configures message routing rules and filters

---

# Headless.Messages.Core

Core implementation of the type-safe messaging system with outbox pattern, message processing, and consumer lifecycle management.

## Problem Solved

Provides the foundational runtime for reliable distributed messaging with transactional outbox, automatic retries, delayed delivery, and type-safe consumer orchestration across multiple transport providers.

## Key Features

- **Outbox Publisher**: Transactional message publishing with database consistency
- **Consumer Management**: Automatic registration, invocation, and lifecycle handling
- **Message Processing**: Retry processor, delayed message scheduler, transport health checks
- **Type-Safe Dispatch**: Reflection-free consumer invocation via compile-time generated code
- **Extension System**: Pluggable storage and transport providers
- **Bootstrapper**: Hosted service for startup and shutdown coordination

## Installation

```bash
dotnet add package Headless.Messages.Core
```

## Quick Start

```csharp
// Register messaging with storage and transport
builder.Services.AddMessages(options =>
{
    // Core configuration
    options.SucceedMessageExpiredAfter = 24 * 3600;
    options.FailedRetryCount = 50;

    // Add storage (required)
    options.UsePostgreSql("connection_string");

    // Add transport (required)
    options.UseRabbitMQ(rmq =>
    {
        rmq.HostName = "localhost";
        rmq.Port = 5672;
    });

    // Register consumers
    options.ScanConsumers(typeof(Program).Assembly);
});

// Publish messages with outbox
public sealed class OrderService(IOutboxPublisher publisher, IOutboxTransaction transaction)
{
    public async Task PlaceOrderAsync(Order order, CancellationToken ct)
    {
        using (transaction.Begin())
        {
            // Database changes and message publish are atomic
            await publisher.PublishAsync("orders.placed", order, cancellationToken: ct);
            await transaction.CommitAsync(ct);
        }
    }
}
```

## Configuration

Register in `Program.cs`:

```csharp
builder.Services.AddMessages(options =>
{
    options.FailedRetryCount = 50;
    options.SucceedMessageExpiredAfter = 24 * 3600;
    options.ConsumerThreadCount = 1;
    options.DefaultGroupName = "myapp";
});
```

## Dependencies

- `Headless.Messages.Abstractions`
- `Headless.Base`
- `Headless.Checks`
- Transport package (RabbitMQ, Kafka, etc.)
- Storage package (PostgreSql, SqlServer, etc.)

## Side Effects

- Starts background hosted service for message processing
- Creates database tables for outbox storage (via storage provider)
- Establishes transport connections (via transport provider)

---

# Headless.Messages.Dashboard

Web-based dashboard for monitoring and managing distributed messaging infrastructure.

## Problem Solved

Provides real-time visibility into message processing, failures, retries, and system health through an embedded web UI for operations and troubleshooting.

## Key Features

- **Real-Time Monitoring**: Live message throughput and latency metrics
- **Message Explorer**: Search, filter, and inspect messages
- **Failure Management**: View and retry failed messages
- **Node Discovery**: Multi-instance cluster visibility
- **Performance Metrics**: Consumer processing stats and bottlenecks

## Installation

```bash
dotnet add package Headless.Messages.Dashboard
```

## Quick Start

```csharp
builder.Services.AddMessages(options =>
{
    options.UsePostgreSql("connection_string");
    options.UseRabbitMQ(config);

    options.UseDashboard(dashboard =>
    {
        dashboard.PathMatch = "/messages";
        dashboard.StatsPollingInterval = 2000;
    });

    options.ScanConsumers(typeof(Program).Assembly);
});

// Access dashboard at: http://localhost:5000/messages
```

## Configuration

```csharp
options.UseDashboard(dashboard =>
{
    dashboard.PathMatch = "/messages";
    dashboard.StatsPollingInterval = 2000;
    dashboard.Authorization = new[] { new CustomDashboardAuthFilter() };
});
```

## Dependencies

- `Headless.Messages.Core`
- Embedded web UI assets

## Side Effects

- Exposes web endpoint at configured path (default: `/cap`)
- Periodically polls message storage for statistics
- Requires authentication configuration for production use

---

# Headless.Messages.Dashboard.K8s

Kubernetes-aware node discovery for the messaging dashboard in clustered environments.

## Problem Solved

Enables automatic discovery and monitoring of messaging nodes in Kubernetes clusters by querying pod endpoints for multi-instance dashboard visibility.

## Key Features

- **Auto-Discovery**: Automatically finds messaging nodes in Kubernetes namespace
- **Service Integration**: Uses Kubernetes Service for node enumeration
- **Health Monitoring**: Tracks node availability and status
- **Dynamic Updates**: Reflects pod scaling events in real-time
- **No Configuration**: Works with default Kubernetes service discovery

## Installation

```bash
dotnet add package Headless.Messages.Dashboard.K8s
```

## Quick Start

```csharp
builder.Services.AddMessages(options =>
{
    options.UsePostgreSql("connection_string");
    options.UseRabbitMQ(config);

    options.UseDashboard();

    options.UseK8sDiscovery(k8s =>
    {
        k8s.Namespace = "production";
        k8s.ServiceName = "messaging-service";
    });

    options.ScanConsumers(typeof(Program).Assembly);
});
```

## Configuration

```csharp
options.UseK8sDiscovery(k8s =>
{
    k8s.Namespace = "production";
    k8s.ServiceName = "messaging-service";
    k8s.Port = 8080;
});
```

## Dependencies

- `Headless.Messages.Dashboard`
- `KubernetesClient`

## Side Effects

- Queries Kubernetes API for pod endpoints
- Requires appropriate RBAC permissions (read pods/endpoints)
- Periodically polls for cluster topology changes

---

# Headless.Messages.InMemoryQueue

In-memory message queue transport for testing and development.

## Problem Solved

Provides a lightweight, no-infrastructure message queue for local development, testing, and single-instance applications without external dependencies.

## Key Features

- **Zero Dependencies**: No external broker required
- **Fast**: In-process message delivery
- **Testing Friendly**: Deterministic, synchronous behavior
- **Same API**: Identical interface to production transports
- **Thread-Safe**: Concurrent producer/consumer support

## Installation

```bash
dotnet add package Headless.Messages.InMemoryQueue
```

## Quick Start

```csharp
builder.Services.AddMessages(options =>
{
    options.UseInMemoryStorage();
    options.UseInMemoryQueue();

    options.ScanConsumers(typeof(Program).Assembly);
});
```

## Configuration

No configuration required. Just call `UseInMemoryQueue()`.

## Dependencies

- `Headless.Messages.Core`

## Side Effects

None. Messages are stored in memory only and lost on restart.

---

# Headless.Messages.InMemoryStorage

In-memory outbox storage for testing and development.

## Problem Solved

Provides ephemeral message storage without database dependencies for local development, integration tests, and prototyping.

## Key Features

- **Zero Dependencies**: No database required
- **Fast**: In-memory operations
- **Testing**: Deterministic behavior for tests
- **Full API**: Complete outbox storage implementation
- **Monitoring**: In-memory dashboard data

## Installation

```bash
dotnet add package Headless.Messages.InMemoryStorage
```

## Quick Start

```csharp
builder.Services.AddMessages(options =>
{
    options.UseInMemoryStorage();
    options.UseRabbitMQ(config);

    options.ScanConsumers(typeof(Program).Assembly);
});
```

## Configuration

No configuration required. Just call `UseInMemoryStorage()`.

## Dependencies

- `Headless.Messages.Core`

## Side Effects

None. All messages are stored in memory and lost on restart. Not suitable for production.

---

# Headless.Messages.Kafka

Apache Kafka transport provider for the messaging system.

## Problem Solved

Enables high-throughput, distributed event streaming using Apache Kafka with consumer groups, partitions, and exactly-once semantics.

## Key Features

- **High Throughput**: Handle millions of messages per second
- **Partitioning**: Parallel processing with ordered delivery per partition
- **Consumer Groups**: Load balancing across consumers
- **Retention**: Persistent message storage with configurable retention
- **Exactly-Once**: Transactional publishing and consuming

## Installation

```bash
dotnet add package Headless.Messages.Kafka
```

## Quick Start

```csharp
builder.Services.AddMessages(options =>
{
    options.UsePostgreSql("connection_string");

    options.UseKafka(kafka =>
    {
        kafka.Servers = "localhost:9092";
    });

    options.ScanConsumers(typeof(Program).Assembly);
});
```

## Configuration

```csharp
options.UseKafka(kafka =>
{
    kafka.Servers = "localhost:9092,localhost:9093";
    kafka.ConnectionPoolSize = 10;
    kafka.CustomHeaders = headers => headers.Add("app", "myapp");
});
```

## Dependencies

- `Headless.Messages.Core`
- `Confluent.Kafka`

## Side Effects

- Creates Kafka topics if they don't exist
- Establishes persistent connections to Kafka brokers
- Joins consumer groups for load balancing

---

# Headless.Messages.NATS

NATS messaging system transport provider for the messaging system.

## Problem Solved

Enables lightweight, cloud-native messaging using NATS with JetStream for persistence, subjects for routing, and NATS Streaming for reliable delivery.

## Key Features

- **Lightweight**: Minimal resource footprint
- **Cloud-Native**: Kubernetes-friendly, easy clustering
- **JetStream**: Persistent streams with at-least-once delivery
- **Subject Routing**: Hierarchical topic patterns (e.g., `orders.*.created`)
- **Request-Reply**: Built-in RPC support

## Installation

```bash
dotnet add package Headless.Messages.NATS
```

## Quick Start

```csharp
builder.Services.AddMessages(options =>
{
    options.UsePostgreSql("connection_string");

    options.UseNATS(nats =>
    {
        nats.Servers = "nats://localhost:4222";
    });

    options.ScanConsumers(typeof(Program).Assembly);
});
```

## Configuration

```csharp
options.UseNATS(nats =>
{
    nats.Servers = "nats://localhost:4222,nats://localhost:4223";
    nats.ConnectionPoolSize = 10;
    nats.EnableJetStream = true;
});
```

## Dependencies

- `Headless.Messages.Core`
- `NATS.Client`

## Side Effects

- Establishes persistent connections to NATS servers
- Creates JetStream streams if enabled
- Subscribes to subjects for message consumption

---

# Headless.Messages.OpenTelemetry

OpenTelemetry instrumentation for distributed tracing and metrics in the messaging system.

## Problem Solved

Provides automatic tracing spans, metrics, and context propagation for message publishing and consumption to enable end-to-end observability across distributed systems.

## Key Features

- **Distributed Tracing**: Automatic span creation for publish/consume operations
- **Context Propagation**: W3C Trace Context header injection/extraction
- **Metrics**: Message throughput, latency, failures, and retry counts
- **Correlation**: Links messages to originating HTTP requests and spans
- **Standard Export**: Compatible with Jaeger, Zipkin, Prometheus, and other backends

## Installation

```bash
dotnet add package Headless.Messages.OpenTelemetry
```

## Quick Start

```csharp
builder.Services.AddOpenTelemetry()
    .WithTracing(tracing => tracing
        .AddSource("Headless.Messages")
        .AddJaegerExporter());

builder.Services.AddMessages(options =>
{
    options.UsePostgreSql("connection_string");
    options.UseRabbitMQ(config);
    options.UseOpenTelemetry();

    options.ScanConsumers(typeof(Program).Assembly);
});
```

## Configuration

```csharp
options.UseOpenTelemetry(otel =>
{
    otel.EnrichPublisher = (activity, message) =>
    {
        activity?.SetTag("message.type", message.GetType().Name);
    };

    otel.EnrichConsumer = (activity, context) =>
    {
        activity?.SetTag("consumer.topic", context.Topic);
    };
});
```

## Dependencies

- `Headless.Messages.Core`
- `OpenTelemetry.Api`
- `OpenTelemetry.Extensions.Hosting`

## Side Effects

- Creates tracing spans for all message operations
- Injects W3C Trace Context headers into messages
- Exports telemetry to configured exporters

---

# Headless.Messages.PostgreSql

PostgreSQL outbox storage provider for the messaging system.

## Problem Solved

Provides durable, transactional message storage using PostgreSQL with automatic schema management, message archival, and high-performance queries.

## Key Features

- **Transactional Outbox**: ACID-compliant message publishing with database changes
- **Auto-Migration**: Automatic table creation and schema updates
- **Archival**: Automatic cleanup of old messages
- **Performance**: Optimized indexes and queries for high throughput
- **Monitoring**: Built-in dashboard data queries

## Installation

```bash
dotnet add package Headless.Messages.PostgreSql
```

## Quick Start

```csharp
builder.Services.AddMessages(options =>
{
    options.UsePostgreSql(config =>
    {
        config.ConnectionString = "Host=localhost;Database=myapp;...";
        config.Schema = "messaging";
    });

    options.UseRabbitMQ(rmq => { /* ... */ });

    options.ScanConsumers(typeof(Program).Assembly);
});
```

## Configuration

```csharp
options.UsePostgreSql(config =>
{
    config.ConnectionString = "connection_string";
    config.Schema = "messaging";
    config.TableNamePrefix = "msg";
});
```

## Dependencies

- `Headless.Messages.Core`
- `Npgsql`

## Side Effects

- Creates database tables in configured schema:
  - `{prefix}_published` - Published messages
  - `{prefix}_received` - Received messages
  - `{prefix}_lock` - Distributed lock table
- Creates indexes for message queries
- Periodically cleans up expired messages

---

# Headless.Messages.Pulsar

Apache Pulsar transport provider for the messaging system.

## Problem Solved

Enables cloud-native, multi-tenant messaging using Apache Pulsar with geo-replication, tiered storage, and unified streaming and queuing models.

## Key Features

- **Multi-Tenancy**: Native namespace and tenant isolation
- **Geo-Replication**: Cross-datacenter message replication
- **Tiered Storage**: Offload old messages to S3/GCS/Azure Blob
- **Unified Model**: Both streaming and queuing semantics
- **Schema Registry**: Built-in schema validation and evolution

## Installation

```bash
dotnet add package Headless.Messages.Pulsar
```

## Quick Start

```csharp
builder.Services.AddMessages(options =>
{
    options.UsePostgreSql("connection_string");

    options.UsePulsar(pulsar =>
    {
        pulsar.ServiceUrl = "pulsar://localhost:6650";
    });

    options.ScanConsumers(typeof(Program).Assembly);
});
```

## Configuration

```csharp
options.UsePulsar(pulsar =>
{
    pulsar.ServiceUrl = "pulsar://localhost:6650";
    pulsar.TenantName = "public";
    pulsar.NamespaceName = "default";
    pulsar.ConnectionPoolSize = 10;
});
```

## Dependencies

- `Headless.Messages.Core`
- `DotPulsar`

## Side Effects

- Creates Pulsar topics in configured tenant/namespace
- Establishes persistent connections to Pulsar brokers
- Creates subscriptions for consumer groups

---

# Headless.Messages.RabbitMQ

RabbitMQ transport provider for the messaging system.

## Problem Solved

Enables reliable message delivery using RabbitMQ with exchanges, queues, routing keys, and advanced AMQP features for flexible pub/sub patterns.

## Key Features

- **Exchange/Queue Model**: Flexible routing with topic, direct, fanout, and headers exchanges
- **Reliability**: Publisher confirms, consumer acknowledgments, and dead-letter exchanges
- **Auto-Provisioning**: Automatic exchange and queue creation
- **Clustering**: High availability with RabbitMQ clusters
- **Priority Queues**: Message priority support

## Installation

```bash
dotnet add package Headless.Messages.RabbitMQ
```

## Quick Start

```csharp
builder.Services.AddMessages(options =>
{
    options.UsePostgreSql("connection_string");

    options.UseRabbitMQ(rmq =>
    {
        rmq.HostName = "localhost";
        rmq.Port = 5672;
        rmq.UserName = "guest";
        rmq.Password = "guest";
        rmq.VirtualHost = "/";
    });

    options.ScanConsumers(typeof(Program).Assembly);
});
```

## Configuration

```csharp
options.UseRabbitMQ(rmq =>
{
    rmq.HostName = "localhost";
    rmq.Port = 5672;
    rmq.UserName = "guest";
    rmq.Password = "guest";
    rmq.VirtualHost = "/";
    rmq.ExchangeName = "myapp.events";
    rmq.ConnectionFactoryOptions = factory =>
    {
        factory.AutomaticRecoveryEnabled = true;
        factory.NetworkRecoveryInterval = TimeSpan.FromSeconds(10);
    };
});
```

## Dependencies

- `Headless.Messages.Core`
- `RabbitMQ.Client`

## Side Effects

- Creates exchanges and queues if they don't exist
- Establishes persistent connections to RabbitMQ
- Configures dead-letter exchanges for failed messages

---

# Headless.Messages.RedisStreams

Redis Streams transport provider for the messaging system.

## Problem Solved

Enables lightweight, high-performance message streaming using Redis Streams with consumer groups, persistence, and at-least-once delivery guarantees.

## Key Features

- **Redis Streams**: Append-only log structure for message streaming
- **Consumer Groups**: Load balancing and parallel processing
- **Persistence**: Durable message storage with configurable retention
- **Claim Messages**: Automatic reprocessing of unacknowledged messages
- **Low Latency**: Sub-millisecond message delivery

## Installation

```bash
dotnet add package Headless.Messages.RedisStreams
```

## Quick Start

```csharp
builder.Services.AddMessages(options =>
{
    options.UsePostgreSql("connection_string");

    options.UseRedisStreams(redis =>
    {
        redis.Configuration = "localhost:6379";
    });

    options.ScanConsumers(typeof(Program).Assembly);
});
```

## Configuration

```csharp
options.UseRedisStreams(redis =>
{
    redis.Configuration = "localhost:6379,ssl=true,password=secret";
    redis.StreamEntriesCount = 10;
    redis.ConnectionPoolSize = 10;
});
```

## Dependencies

- `Headless.Messages.Core`
- `StackExchange.Redis`

## Side Effects

- Creates Redis Streams for each topic
- Creates consumer groups for message distribution
- Maintains persistent connections to Redis
- Periodically claims pending messages for retry

---

# Headless.Messages.SqlServer

SQL Server outbox storage provider for the messaging system.

## Problem Solved

Provides durable, transactional message storage using SQL Server with automatic schema management, message archival, and optimized queries for Windows environments.

## Key Features

- **Transactional Outbox**: ACID-compliant message publishing with database changes
- **Auto-Migration**: Automatic table creation and schema updates
- **Archival**: Automatic cleanup of old messages
- **Performance**: Optimized indexes and queries for SQL Server
- **Monitoring**: Built-in dashboard data queries

## Installation

```bash
dotnet add package Headless.Messages.SqlServer
```

## Quick Start

```csharp
builder.Services.AddMessages(options =>
{
    options.UseSqlServer(config =>
    {
        config.ConnectionString = "Server=localhost;Database=myapp;...";
        config.Schema = "messaging";
    });

    options.UseRabbitMQ(rmq => { /* ... */ });

    options.ScanConsumers(typeof(Program).Assembly);
});
```

## Configuration

```csharp
options.UseSqlServer(config =>
{
    config.ConnectionString = "connection_string";
    config.Schema = "messaging";
    config.TableNamePrefix = "msg";
});
```

## Dependencies

- `Headless.Messages.Core`
- `Microsoft.Data.SqlClient`

## Side Effects

- Creates database tables in configured schema:
  - `{prefix}_published` - Published messages
  - `{prefix}_received` - Received messages
  - `{prefix}_lock` - Distributed lock table
- Creates indexes for message queries
- Periodically cleans up expired messages

---

# Headless.ResourceLocks.InMemory

In-memory resource lock provider for single-instance deployments, development, and testing.

## Problem Solved

Provides lightweight distributed locking and throttling using in-memory storage without external dependencies. Suitable for single-instance applications, local development, and testing scenarios.

## Key Features

- **Zero Dependencies**: No Redis or database required
- **Fast**: In-process lock operations
- **Throttling Support**: Rate limiting with in-memory storage
- **Keyed Locks**: Multiple named lock instances
- **Testing**: Deterministic behavior for tests

## Installation

```bash
dotnet add package Headless.ResourceLocks.InMemory
```

## Quick Start

```csharp
// Register in-memory resource locks
builder.Services.AddInMemoryResourceLock();

// Use resource locks
public sealed class OrderService(IResourceLockProvider locks)
{
    public async Task ProcessOrderAsync(string orderId, CancellationToken ct)
    {
        await using var lockHandle = await locks.AcquireAsync(
            $"order:{orderId}",
            TimeSpan.FromSeconds(30),
            ct);

        if (lockHandle == null)
        {
            // Lock acquisition failed, order is being processed elsewhere
            return;
        }

        // Process order with exclusive lock
    }
}

// Throttling example
builder.Services.AddInMemoryThrottlingResourceLock(new ThrottlingResourceLockOptions
{
    MaxRequests = 100,
    TimeWindow = TimeSpan.FromMinutes(1)
});
```

## Configuration

```csharp
// Basic resource lock
builder.Services.AddInMemoryResourceLock((options, sp) =>
{
    options.DefaultExpiration = TimeSpan.FromMinutes(5);
});

// Throttling lock
builder.Services.AddInMemoryThrottlingResourceLock(new ThrottlingResourceLockOptions
{
    MaxRequests = 100,
    TimeWindow = TimeSpan.FromMinutes(1)
});

// Keyed throttling lock
builder.Services.AddKeyedInMemoryThrottlingResourceLock("api", new ThrottlingResourceLockOptions
{
    MaxRequests = 1000,
    TimeWindow = TimeSpan.FromMinutes(1)
});
```

## Dependencies

- `Headless.ResourceLocks.Cache`
- `Headless.Caching.Memory`
- `Headless.Messaging.Abstractions`

## Side Effects

None. Locks are stored in memory only and lost on restart. Not suitable for multi-instance production deployments.

---

# Headless.Send.Abstractions

> **Note:** This package is currently a placeholder and contains no implementation.

## Status

This package directory exists for future development. Sending functionality is currently available through:
- `Headless.Emails.Abstractions` - Email sending abstractions
- `Headless.Sms.Abstractions` - SMS sending abstractions
- `Headless.PushNotifications.Abstractions` - Push notification abstractions

## Installation

Not available for installation.

---

# Headless.Send.Core

> **Note:** This package is currently a placeholder and contains no implementation.

## Status

This package directory exists for future development. Sending functionality is currently available through:
- `Headless.Emails.Core` - Email sending core implementation
- `Headless.Sms.*` - SMS provider implementations
- `Headless.PushNotifications.*` - Push notification implementations

## Installation

Not available for installation.

---

# Headless.Ticker.Abstractions

Simple utilities for queuing and executing cron/time-based jobs in the background.
Part of the [TickerQ](https://github.com/arcenox/TickerQ) suite by [Arcenox](https://arcenox.com).

---

##  Installation

```bash
dotnet add package Headless.Ticker.Utilities
---

# Headless.Ticker.Caching.Redis

Redis-backed distributed coordination for TickerQ with node heartbeat monitoring and dead node detection.

## Problem Solved

Enables multi-instance TickerQ deployments with Redis-based node registry, heartbeat monitoring, and automatic dead node cleanup for high availability job scheduling.

## Key Features

- **Node Registry**: Track all TickerQ nodes in Redis
- **Heartbeat Monitoring**: Periodic node liveness checks
- **Dead Node Detection**: Automatic cleanup of failed nodes
- **Distributed Coordination**: Shared state across TickerQ instances
- **Dashboard Integration**: Real-time cluster visibility

## Installation

```bash
dotnet add package Headless.Ticker.Caching.Redis
```

## Quick Start

```csharp
builder.Services.AddTickerQ(options =>
{
    options.MaxConcurrency(10);

    // Enable Redis coordination
    options.UseRedisCoordination(redis =>
    {
        redis.ConnectionString = "localhost:6379";
        redis.NodeHeartbeatInterval = TimeSpan.FromSeconds(30);
    });
});

app.UseTickerQ();
```

## Configuration

```csharp
options.UseRedisCoordination(redis =>
{
    redis.ConnectionString = "localhost:6379,ssl=true,password=secret";
    redis.NodeHeartbeatInterval = TimeSpan.FromSeconds(30);
    redis.NodeIdentifier = "instance-1"; // Auto-generated if not set
});
```

## Dependencies

- `Headless.Ticker.Abstractions`
- `Microsoft.Extensions.Caching.StackExchangeRedis`

## Side Effects

- Stores node registry and heartbeats in Redis
- Background service sends periodic heartbeats
- Periodically scans for and removes dead nodes
- Creates Redis keys: `nodes:registry`, `hb:{nodeId}`

---

# Headless.Ticker.Core

Core implementation of TickerQ, a high-performance background job scheduler for .NET with cron expressions and time-based scheduling.

## Problem Solved

Provides reliable, distributed background job scheduling with cron expressions, delayed execution, custom task scheduling, and real-time monitoring without external dependencies like Hangfire or Quartz.

## Key Features

- **Cron Scheduling**: Full cron expression support with timezone handling
- **Time-Based Jobs**: Schedule jobs at specific times or intervals
- **Custom Thread Pool**: Optimized task scheduler for background jobs
- **Persistence**: In-memory or database-backed job storage
- **Fallback**: Automatic recovery and retry for failed jobs
- **Zero Allocations**: High-performance execution with minimal GC pressure
- **Hot Reload**: Dynamic job registration and configuration updates

## Installation

```bash
dotnet add package Headless.Ticker.Core
```

## Quick Start

```csharp
// Register TickerQ
builder.Services.AddTickerQ(options =>
{
    options.MaxConcurrency(10);
    options.TimeZone(TimeZoneInfo.FindSystemTimeZoneById("America/New_York"));
});

// Define cron job
[TickerQ("*/5 * * * *")] // Every 5 minutes
public static class CleanupJob
{
    public static async Task ExecuteAsync(IServiceProvider sp, CancellationToken ct)
    {
        var logger = sp.GetRequiredService<ILogger<CleanupJob>>();
        logger.LogInformation("Running cleanup job");

        await Task.CompletedTask;
    }
}

// Initialize TickerQ
app.UseTickerQ();

// Schedule time-based job programmatically
public sealed class OrderService(ITimeTickerManager<TimeTickerEntity> ticker)
{
    public async Task SendReminderAsync(string orderId, CancellationToken ct)
    {
        await ticker.ScheduleAsync(new TimeTickerEntity
        {
            TickerKey = $"order-reminder-{orderId}",
            OccurrenceTime = DateTime.UtcNow.AddHours(24),
            Request = new { OrderId = orderId }
        }, ct);
    }
}
```

## Configuration

```csharp
builder.Services.AddTickerQ(options =>
{
    // Scheduler options
    options.MaxConcurrency(10);
    options.IdleWorkerTimeout(TimeSpan.FromMinutes(5));
    options.TimeZone(TimeZoneInfo.Utc);

    // Seeding options
    options.SeedDefinedCronTickers = true;
    options.CustomTimeSeeder = async sp =>
    {
        // Seed initial jobs
    };

    // Exception handling
    options.UseExceptionHandler<CustomTickerExceptionHandler>();

    // Disable background services (for testing)
    options.DisableBackgroundServices();
});

// Start modes
app.UseTickerQ(TickerQStartMode.Immediate); // Start immediately (default)
app.UseTickerQ(TickerQStartMode.Manual);    // Wait for manual trigger
```

## Dependencies

- `Headless.Ticker.Abstractions`
- `Headless.Base`

## Side Effects

- Starts background hosted services for job scheduling and execution
- Creates in-memory job storage (or database tables with persistence providers)
- Runs custom thread pool for job execution
- Periodically scans for due jobs and executes them

---

# Headless.Ticker.Dashboard

Simple, clean authentication for your TickerQ Dashboard.

##  Quick Examples

### No Authentication (Public Dashboard)
```csharp
services.AddTickerQ<MyTimeTicker, MyCronTicker>(config =>
{
    config.AddDashboard(dashboard =>
    {
        // No authentication setup = public dashboard
    });
});
```

### Basic Authentication
```csharp
services.AddTickerQ<MyTimeTicker, MyCronTicker>(config =>
{
    config.AddDashboard(dashboard =>
    {
        dashboard.WithBasicAuth("admin", "secret123");
    });
});
```

### API Key Authentication
```csharp
services.AddTickerQ<MyTimeTicker, MyCronTicker>(config =>
{
    config.AddDashboard(dashboard =>
    {
        dashboard.WithApiKey("my-secret-api-key-12345");
    });
});
```

### Use Host Application's Authentication
```csharp
services.AddTickerQ<MyTimeTicker, MyCronTicker>(config =>
{
    config.AddDashboard(dashboard =>
    {
        dashboard.WithHostAuthentication();
    });
});
```

### Use Host Authentication with Custom Policy
```csharp
services.AddTickerQ<MyTimeTicker, MyCronTicker>(config =>
{
    config.AddDashboard(dashboard =>
    {
        dashboard.WithHostAuthentication("AdminPolicy");
    });
});
```

##  Fluent API Methods

- `WithBasicAuth(username, password)` - Enable username/password authentication
- `WithApiKey(apiKey)` - Enable API key authentication
- `WithHostAuthentication(policy)` - Use your app's existing auth with optional policy (e.g., "AdminPolicy")
- `SetBasePath(path)` - Set dashboard URL path
- `SetBackendDomain(domain)` - Set backend API domain
- `SetCorsPolicy(policy)` - Configure CORS

##  How It Works

The dashboard automatically detects your authentication method:

1. **No auth configured**  Public dashboard
2. **Basic auth configured**  Username/password login
3. **Bearer token configured**  API key authentication
4. **Host auth configured**  Delegates to your app's auth system

##  Frontend Integration

The frontend automatically adapts based on your backend configuration:
- Shows appropriate login UI
- Handles SignalR authentication
- Supports both header and query parameter auth (for WebSockets)

That's it! Simple and clean. 

---

# Headless.Ticker.EntityFramework

Entity Framework Core integration for [TickerQ](https://github.com/arcenox/TickerQ), a high-performance background job scheduler for .NET.

This package enables persistence of time-based and cron-based jobs using EF Core, allowing for robust tracking, retry logic, and job state management.

---

##  Installation

```bash
dotnet add package Headless.Ticker.EntityFrameworkCore
---

# Headless.Ticker.OpenTelemetry

OpenTelemetry instrumentation package for TickerQ job scheduler with distributed tracing support.

## Features

- **Distributed Tracing**: Full OpenTelemetry activity/span creation for job execution lifecycle
- **Structured Logging**: Rich logging with job context through ILogger integration
- **Parent-Child Relationships**: Maintains trace relationships between parent and child jobs
- **Retry Tracking**: Tracks retry attempts with detailed context
- **Performance Metrics**: Comprehensive execution time and outcome tracking
- **Error Tracking**: Detailed exception and cancellation tracking
- **Caller Information**: Automatic detection of where jobs are enqueued from

## Installation

```bash
dotnet add package Headless.Ticker.Instrumentation.OpenTelemetry
```

## Usage

### Basic Setup

```csharp
using Headless.Ticker.Instrumentation.OpenTelemetry;
using OpenTelemetry.Trace;

var builder = WebApplication.CreateBuilder(args);

// Configure OpenTelemetry with TickerQ ActivitySource
builder.Services.AddOpenTelemetry()
    .WithTracing(tracing =>
    {
        tracing.AddSource("TickerQ") // Add TickerQ ActivitySource
               .AddConsoleExporter()
               .AddJaegerExporter();
    });

// Add TickerQ with OpenTelemetry instrumentation
builder.Services.AddTickerQ<MyTimeTicker, MyCronTicker>(options => { })
    .AddOperationalStore(ef => { })
    .AddOpenTelemetryInstrumentation(); //  Enable tracing

var app = builder.Build();
app.Run();
```

### With Jaeger

```csharp
builder.Services.AddOpenTelemetry()
    .WithTracing(tracing =>
    {
        tracing.AddTickerQInstrumentation()
               .AddJaegerExporter(options =>
               {
                   options.Endpoint = new Uri("http://localhost:14268/api/traces");
               });
    });
```

### With Application Insights

```csharp
builder.Services.AddOpenTelemetry()
    .WithTracing(tracing =>
    {
        tracing.AddTickerQInstrumentation()
               .AddAzureMonitorTraceExporter();
    });
```

## Trace Structure

### Job Execution Activities
```
Headless.Ticker.job.execute.timeticker (main job execution span)
 Headless.Ticker.job.enqueued (when job starts execution)
 Headless.Ticker.job.completed (on successful completion)
 Headless.Ticker.job.failed (on failure)
 Headless.Ticker.job.cancelled (on cancellation)
 Headless.Ticker.job.skipped (when skipped)
 Headless.Ticker.seeding.started (for data seeding)
 Headless.Ticker.seeding.completed (seeding completion)
```

### Tags Added to Activities

| Tag | Description | Example |
|-----|-------------|---------|
| `Headless.Ticker.job.id` | Unique job identifier | `123e4567-e89b-12d3-a456-426614174000` |
| `Headless.Ticker.job.type` | Type of ticker | `TimeTicker`, `CronTicker` |
| `Headless.Ticker.job.function` | Function name being executed | `ProcessEmails` |
| `Headless.Ticker.job.priority` | Job priority | `Normal`, `High`, `LongRunning` |
| `Headless.Ticker.job.machine` | Machine executing the job | `web-server-01` |
| `Headless.Ticker.job.parent_id` | Parent job ID (for child jobs) | `parent-job-guid` |
| `Headless.Ticker.job.enqueued_from` | Where the job was enqueued from | `UserController.CreateUser (Program.cs:42)` |
| `Headless.Ticker.job.is_due` | Whether the job was due | `true`, `false` |
| `Headless.Ticker.job.is_child` | Whether this is a child job | `true`, `false` |
| `Headless.Ticker.job.retries` | Maximum retry attempts | `3` |
| `Headless.Ticker.job.current_attempt` | Current retry attempt | `1`, `2`, `3` |
| `Headless.Ticker.job.final_status` | Final execution status | `Done`, `Failed`, `Cancelled`, `Skipped` |
| `Headless.Ticker.job.final_retry_count` | Final retry count reached | `2` |
| `Headless.Ticker.job.execution_time_ms` | Execution time in milliseconds | `1250` |
| `Headless.Ticker.job.success` | Whether execution was successful | `true`, `false` |
| `Headless.Ticker.job.error_type` | Exception type for failures | `SqlException`, `TimeoutException` |
| `Headless.Ticker.job.error_message` | Error message | `Connection timeout` |
| `Headless.Ticker.job.error_stack_trace` | Full stack trace | `at MyService.ProcessData()...` |
| `Headless.Ticker.job.cancellation_reason` | Reason for cancellation | `Task was cancelled` |
| `Headless.Ticker.job.skip_reason` | Reason for skipping | `Another instance is already running` |

## Logging Output

The instrumentation provides structured logging for all job events:

```
[INF] TickerQ Job enqueued: TimeTicker - ProcessEmails (123e4567-e89b-12d3-a456-426614174000) from ExecutionTaskHandler
[INF] TickerQ Job completed: ProcessEmails (123e4567-e89b-12d3-a456-426614174000) in 1250ms - Success: True
[ERR] TickerQ Job failed: ProcessEmails (123e4567-e89b-12d3-a456-426614174000) - Retry 1 - Connection timeout
[INF] TickerQ Job completed: ProcessEmails (123e4567-e89b-12d3-a456-426614174000) in 2500ms - Success: False
[WRN] TickerQ Job cancelled: ProcessEmails (123e4567-e89b-12d3-a456-426614174000) - Task was cancelled
[INF] TickerQ Job skipped: ProcessEmails (123e4567-e89b-12d3-a456-426614174000) - Another CronOccurrence is already running!
[INF] TickerQ start seeding data: TimeTicker (production-node-01)
[INF] TickerQ completed seeding data: TimeTicker (production-node-01)
```

## Integration with Logging Frameworks

This package works seamlessly with any logging framework that integrates with `ILogger`:

### Serilog
```csharp
builder.Host.UseSerilog((context, config) =>
{
    config.WriteTo.Console()
          .WriteTo.File("logs/tickerq-.txt", rollingInterval: RollingInterval.Day)
          .Enrich.FromLogContext();
});
```

### NLog
```csharp
builder.Logging.ClearProviders();
builder.Logging.AddNLog();
```

## Performance Impact

- **Minimal Overhead**: Activities are only created when OpenTelemetry listeners are active
- **Efficient Logging**: Uses structured logging with minimal string allocations
- **Conditional Tracing**: No performance impact when tracing is disabled

## Requirements

- .NET 8.0 or later
- OpenTelemetry 1.7.0 or later
- Headless.Ticker.Abstractions (automatically included)

---

# Headless.Ticker.SourceGenerator

C# source generator for TickerQ that generates boilerplate code for background job registration and execution.

## Problem Solved

Eliminates reflection overhead and manual job registration by generating compile-time code for TickerQ job functions marked with `[TickerQ]` attribute.

## Key Features

- **Zero Reflection**: Compile-time code generation
- **Auto-Registration**: Automatic job discovery and registration
- **Type Safety**: Compile-time validation of job signatures
- **DI Integration**: Generates constructor injection code
- **Incremental**: Fast rebuild with incremental generation
- **Diagnostics**: Rich compile-time error messages

## Installation

```bash
dotnet add package Headless.Ticker.SourceGenerator
```

## Quick Start

```csharp
// Define job with attribute
[TickerQ("*/5 * * * *")] // Every 5 minutes
public static class CleanupJob
{
    public static async Task ExecuteAsync(IServiceProvider sp, CancellationToken ct)
    {
        var logger = sp.GetRequiredService<ILogger<CleanupJob>>();
        logger.LogInformation("Running cleanup");
    }
}

// Source generator creates:
// - Job registration code
// - Execution delegates
// - Constructor injection
// - Request type mapping

// No manual registration needed - jobs auto-discovered at compile time
```

## Configuration

No runtime configuration. Uses attributes:

```csharp
// Cron job
[TickerQ("0 0 * * *", Priority = TickerTaskPriority.High)]
public static class DailyReport { /* ... */ }

// Job with request payload
[TickerQ("ProcessOrder")]
public sealed class OrderProcessor(IOrderService orders)
{
    public async Task ExecuteAsync(
        TickerFunctionContext<OrderRequest> context,
        CancellationToken ct)
    {
        await orders.ProcessAsync(context.Request, ct);
    }
}

// Custom constructor
public sealed class ComplexJob
{
    [TickerQConstructor]
    public ComplexJob(ILogger<ComplexJob> logger, IConfiguration config)
    {
        // Custom initialization
    }

    [TickerQ("ComplexTask")]
    public async Task ExecuteAsync(/* ... */) { }
}
```

## Dependencies

- `Microsoft.CodeAnalysis.CSharp` (analyzer/generator)

## Side Effects

Generates `TickerQInstanceFactoryExtensions.g.cs` at compile time with:
- Module initializer for auto-registration
- Job execution delegates
- Constructor factory methods
- Request type registrations

---
